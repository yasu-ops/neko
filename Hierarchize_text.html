<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Textarea Application</title>
    <style>
        .textarea-container {
            display: flex;
            align-items: flex-start;
            margin-bottom: 10px;
            position: relative;
        }
        .controls {
            margin-right: 10px;
        }
        .textarea-wrapper {
            position: relative;
        }
        textarea {
            width: 300px;
            min-height: 24px;
            resize: none;
            overflow-y: hidden;
            box-sizing: border-box;
            padding: 4px;
            line-height: 16px;
            font-family: monospace;
        }
        .textarea-number {
            position: absolute;
            right: -30px;
            top: 0;
            width: 30px;
            text-align: center;
            box-sizing: border-box;
            padding: 4px 2px;
            font-family: monospace;
            font-size: 14px;
            color: #999;
            background-color: #f0f0f0;
            user-select: none;
        }
        #moto {
            display: none;
        }
    </style>
</head>
<body>
    ★★テキスト階層化アプリ★★<br>
    このサイトでは、図の生成に <a href="https://mermaid-js.github.io/mermaid/#/" target="_blank">Mermaid.js</a> を、HTML要素の画像化に <a href="https://html2canvas.hertzen.com/" target="_blank">html2canvas</a> を使用しています。<br><br>

    <table>
        <tr>
            <td style="vertical-align: top;"　width="60%">
                <div id="app"></div>
                <textarea id="moto"></textarea><br> 
                <!--<button onclick="myfunction()">ツリー図作成step2：ツリー図作成</button>-->
                <pre id="yasu">
                </pre>

                <script type="module">
                    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
                    mermaid.initialize({ startOnLoad: false,securityLevel: 'loose' });
                    window.myfunction=function make_tree(){
                        document.getElementById("yasu").removeAttribute('data-processed');
                        document.getElementById("yasu").innerHTML="";
                        document.getElementById("yasu").innerHTML=document.getElementById("moto").value;
                        mermaid.run({nodes:[document.getElementById("yasu")]});
                    }
                </script>

                <div id="dst">
                </div>

                <button onclick="captureHighResImage()">表示されているツリー図やマインドマップを画像としてコピー</button>

                <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
                <script>
                async function captureHighResImage() {
                    const src = document.getElementById('yasu');
                    const svg = src.querySelector('svg');
                    
                    if (!svg) {
                        console.error('SVG element not found');
                        return;
                    }
                    
                    const bbox = svg.getBBox();
                    const svgRect = svg.getBoundingClientRect();
                    
                    // スケール係数を計算
                    const scaleX = svgRect.width / bbox.width;
                    const scaleY = svgRect.height / bbox.height;
                    
                    // 基本的なスケールファクター（デバイスのピクセル比）
                    const baseScale = window.devicePixelRatio || 1;
                    
                    // 追加の解像度倍率（必要に応じて調整）
                    const resolutionMultiplier = 2;
                    
                    // 最終的なスケールファクター
                    const finalScale = baseScale * resolutionMultiplier;
                    
                    // キャプチャ範囲を計算（下部に余白を追加）
                    const captureWidth = Math.ceil(bbox.width * scaleX);
                    const captureHeight = Math.ceil(bbox.height * scaleY + 20); // 20pxの余白
                    
                    const canvas = await html2canvas(src, {
                        width: captureWidth,
                        height: captureHeight,
                        x: bbox.x * scaleX,
                        y: bbox.y * scaleY,
                        scale: finalScale,
                        logging: false,
                        useCORS: true, // クロスオリジンの画像をサポート
                        allowTaint: false, // セキュリティのため、デフォルトはfalse
                        backgroundColor: null // 透明背景
                    });

                    // 以下、キャンバスの処理（クリップボードへのコピーなど）
                    canvas.toBlob(function(blob) {
                        const item = new ClipboardItem({ "image/png": blob });
                        navigator.clipboard.write([item]).then(() => {
                            console.log('Image copied to clipboard');
                        }).catch(err => {
                            console.error('Failed to copy image: ', err);
                        });
                    });
                    // ここでcanvasを削除します
                    canvas.remove();
                }   
                
                </script>
            
            </td>
            <td style="vertical-align: top;" width="40%">
            使い方
            <ul>
                <li>テキストボックスの中で
                    <blockquote>
                    <li><b>上矢印キーを押す</b>　上のテキストボックスへカーソルが移動する。</li>
                    <li><b>下矢印キーを押す</b>　下のテキストボックスへカーソルが移動する。</li>
                    <li><b>Enterキーを押す</b>　下に新たなテキストボックスが生成される。</li>
                    </blockquote>
                <li>テキストボックスの上にあるボタン
                    <blockquote>
                    <li><b>csv保存ボタン</b>　現在の表示内容を保存。</li>
                    <li><b>ファイルの選択ボタン</b>　保存した内容を読み込む。</li>
                    <li><b>全グループ化解除</b>　グループ化されたテキストボックスのグループ化を解除する。</li>
                    </blockquote>   
                <li>テキストボックスの左側にあるボタン
                    <blockquote>
                    <li><b>消ボタン</b>　その行のテキストボックスを削除。</li>
                    <li><b>→ボタンまたはタブキー</b>　テキストボックスを右にずらす。</li>
                    <li><b>←ボタンまたはシフト＋タブキー</b>　テキストボックスを左にずらす。</li>
                    <li><b>↑ボタンまたはctrl+上矢印キー</b>　テキストボックスを１つ上に移動。</li>
                    <li><b>↓ボタンまたはctrl+下矢印キー</b>　テキストボックスを１つ下に移動。</li>
                    <li><b>たたむボタン</b>　そのテキストボックスより下位のテキストボックスが非表示になる。（たたむと、自動的にグループ化される。グループ化についてはGボタンの項を参照。）</li>
                    <li><b>ひらくボタン</b>　テキストボックスの下の非表示のテキストボックスを再表示する。</li>
                    <li><b>Gボタン</b>　そのテキストボックスとそれより下位のテキストボックスを１かたまりのグループにする。グループ化されたものは上下移動するとき、まとまって動く。Gボタンをもう一度押すとグループは解除される。</li>
                    </blockquote>   
                <li>テキストボックスの下にあるボタン
                    <blockquote>
                    <li><b>word文書として保存</b>　現在の表示内容をword文書として保存。</li>
                    <li><b>左→右のツリーボタン</b>　テキストボックスの階層構造をもとに左右のツリーを生成。</li>
                    <li><b>上→下のツリーボタン</b>　テキストボックスの階層構造をもとに上下のツリーを生成。</li>
                    <li><b>ツリー図で分岐した枝を再び１本に戻したい場合</b>　<u>分岐された（並列された状態にある）テキストボックスのうち</u>、先頭のテキストボックス以外の、残りのテキストボックスの行頭に半角の+を入れる。そのあとに下位のテキストボックスを追加すると、並列されたテキストボックスが全部、その下位のテキストボックスにつながり、１本のラインに戻る。</li>
                    <li><b>マインドマップ</b>　マインドマップを生成　※注意　マインドマップを作るためには（１）最初のテキストボックスは字下げせず、（２）２つ目以降のテキストボックスがすべて字下げされている必要がある。</li>
                    </blockquote>
            </ul>

            </td>
        </tr>
    </table>
    

    <script>
        class TextareaManager {
            constructor() {
                this.app = document.getElementById('app');
                this.textareas = [];
                //output用
                this.outputArea = null;
                //this.highlightedGroup = null;
                this.addTextarea();
                //this.addClearButton();
                //this.addimportButton();
                //this.addexportButton();
                //this.createCSVFileInput();

                // yas01 グループ番号管理のための追加
                this.maxGroupNumber = 0;
                this.groupNumberDisplay = document.createElement('div');
                this.groupNumberDisplay.id = 'max-group-number';
                document.body.insertBefore(this.groupNumberDisplay, document.body.firstChild);
                this.updateMaxGroupNumberDisplay();  

                // 新しい出力エリアの追加
                //this.createOutputArea();
                
            }

            // 新しいメソッド: 出力エリアの作成
            createOutputArea() {

                this.outputArea = document.createElement('div');
                this.outputArea.id = 'output-area';
                //this.outputArea.contentEditable = true; // リッチテキストの編集を可能にする
                this.outputArea.style.border = '1px solid #ccc';
                this.outputArea.style.padding = '10px';
                this.outputArea.style.marginTop = '20px';
                this.outputArea.style.minHeight = '100px';
                this.outputArea.style.fontFamily = 'monospace'; // 等幅フォントを使用
                this.outputArea.style.display = 'none'; // 初期状態で非表示
                

                const outputButton = document.createElement('button');
                outputButton.textContent = 'word文書として保存';
                outputButton.onclick = () => this.writeOutput();
                
                const outputButton2 = document.createElement('button');
                outputButton2.textContent = '左→右のツリー';
                outputButton2.onclick = () => this.writeOutput4(1);

                const outputButton2_2 = document.createElement('button');
                outputButton2_2.textContent = '上→下のツリー';
                outputButton2_2.onclick = () => this.writeOutput4(2);

                const outputButton3 = document.createElement('button');
                outputButton3.textContent = 'マインドマップにする';
                outputButton3.onclick = () => this.writeOutput3();

                this.app.appendChild(outputButton);
                this.app.appendChild(outputButton2);
                this.app.appendChild(outputButton2_2);
                this.app.appendChild(outputButton3);

                this.app.appendChild(this.outputArea);
            }

            writeOutput3() {
                let output = '';
                const textareasData = [];
                let tmp;
                this.textareas.forEach(textareaDiv => {
                    const textarea = textareaDiv.querySelector('textarea');
                    const indent = Math.floor(parseInt(textarea.style.marginLeft) / 20);
                    const spaces = ' '.repeat(indent);
                    if(textarea.value.slice(0,1)==='+'){
                        tmp=textarea.value.slice(1);
                    } else {
                        tmp=textarea.value;
                    }

                    const escapedText = spaces+tmp+'\n';
                    
                    output += escapedText;
                    
                });

                //this.outputArea.innerHTML = output;
                document.getElementById('moto').innerHTML = 'mindmap\n'+output;
                window.myfunction();
            }


            old_writeOutput() {
                let output = '';
                this.textareas.forEach(textareaDiv => {
                    const textarea = textareaDiv.querySelector('textarea');
                    const indent = Math.floor(parseInt(textarea.style.marginLeft) / 20);
                    const indentPx = indent * 20;
                    
                    const escapedText = this.escapeHtml(textarea.value).replace(/\n/g, '<br>');
                    /*
                    output += `<blockquote style="margin-left: ${indentPx}px; padding-left: 10px; line-height: 1.3;">
                        ${escapedText}
                    </blockquote>`;
                    */
                    
                    output += `<blockquote style="margin-left: ${indentPx}px; padding-left: 10px; line-height: 1.3;">
                        <ul><li>${escapedText}</ul>
                    </blockquote>`;
                    
                });
                this.outputArea.innerHTML = output;
                if (output.trim() !== "") {
                    this.outputArea.style.display = 'block';
                } else {
                    this.outputArea.style.display = 'none';
                }
            }

            writeOutput() {
                let output =  '{\\rtf1\\ansi\\deff0 {\\fonttbl{\\f0 Times New Roman;}}\n';
                this.textareas.forEach(textareaDiv => {
                    const textarea = textareaDiv.querySelector('textarea');
                    const indent = Math.floor(parseInt(textarea.style.marginLeft) / 20);
                    const indentPx = indent * 210;
                    
                    output += `{\\pard\\li${indentPx} ` + this.escapeRTF(textarea.value) + '\\par\\par}\n';
                });
                output += '}'
                this.downloadRTF(output, 'outline.doc')
            }

            escapeRTF(text) {
                return text.replace(/[\\{}]/g, '\\$&')
                        .replace(/\n/g, '\\par ')
                        .replace(/[^\u0000-\u007F]/g, char => '\\u' + char.charCodeAt(0) + '?');
            }

            downloadRTF(content, filename) {
                const blob = new Blob([content], { type: 'application/rtf' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.click();
                URL.revokeObjectURL(link.href);
            }

            // 新しいメソッド: テキストの書き出し
            writeOutput2(num) {
                let output = '';
                const textareasData = [];
                
                // アルファベットの呼び名を生成する関数
                const generateAlphabetLabel = (index) => {
                    let label = '';
                    while (index >= 0) {
                        label = String.fromCharCode((index % 26) + 65) + label;
                        index = Math.floor(index / 26) - 1;
                    }
                    return label;
                };

                // テキストエリアの内容を収集
                this.textareas.forEach((textareaDiv, index) => {
                    const textarea = textareaDiv.querySelector('textarea');
                    const indent = Math.floor(parseInt(textarea.style.marginLeft) / 20);
                    const content = this.escapeHtml(textarea.value).replace(/\n/g, '<br>');
                    const label = generateAlphabetLabel(index);
                    textareasData.push({ label, content, indent });
                });

                // 関連付けと出力の生成
                for (let i = 1; i < textareasData.length; i++) {
                    const current = textareasData[i];
                    if (current.indent > 0) {
                        let relatedLabel = '';
                        for (let j = i - 1; j >= 0; j--) {
                            if (textareasData[j].indent < current.indent) {
                                relatedLabel = textareasData[j].label;
                                //output += `${relatedLabel}[${textareasData[j].content}]---${current.label}[${current.content}]<br>`;
                                output += `${relatedLabel}[${textareasData[j].content}]---${current.label}[${current.content}]\n`;
                                break;
                            }
                        }
                    }
                }

                //this.outputArea.innerHTML = output;
                let mae_str;
                if(num===1){
                    mae_str='graph LR';
                } else{
                    mae_str='graph TB';
                }
                
                document.getElementById('moto').innerHTML = mae_str+'\n'+output;
                window.myfunction();

            }

            writeOutput4(num){ 
                let output = '';
                const textareasData = [];
                let temp;
                
                // アルファベットの呼び名を生成する関数
                const generateAlphabetLabel = (index) => {
                    let label = '';
                    while (index >= 0) {
                        label = String.fromCharCode((index % 26) + 65) + label;
                        index = Math.floor(index / 26) - 1;
                    }
                    return label;
                };

                // テキストエリアの内容を収集
                this.textareas.forEach((textareaDiv, index) => {
                    const textarea = textareaDiv.querySelector('textarea');
                    const indent = Math.floor(parseInt(textarea.style.marginLeft) / 20);
                    const content = this.escapeHtml(textarea.value).replace(/\n/g, '<br>');
                    const label = generateAlphabetLabel(index);
                    textareasData.push({ label, content, indent });
                });


                // 関連付けと出力の生成
                for (let i = 0; i < textareasData.length; i++) {
                    const current = textareasData[i];
                    temp=current.content;
                    if(temp.slice(0,1)==='+'){
                        temp=temp.slice(1);
                    }
                    output += `${current.label}[${temp}]\n`;
                }

                // 関連付けと出力の生成
                for (let i = 1; i < textareasData.length; i++) {
                    const current = textareasData[i];
                    if (current.indent > 0) {
                        let relatedLabel = '';
                        for (let j = i - 1; j >= 0; j--) {
                            if (textareasData[j].indent < current.indent) {
                                if(textareasData[j].content.slice(0,1)==='+'){
                                    let k=j;
                                    relatedLabel=textareasData[k].label;
                                    while(textareasData[k].content.slice(0,1)==='+' && k > 0){
                                        relatedLabel = textareasData[k-1].label +' & ' + relatedLabel;
                                        k--;                                    
                                    }
                                } else {   
                                    relatedLabel = textareasData[j].label;
                                }
                                output += `${relatedLabel}---${current.label}\n`;
                                break;
                            }
                        }
                    }
                }

                //this.outputArea.innerHTML = output;
                let mae_str;
                if(num===1){
                    mae_str='graph LR';
                } else{
                    mae_str='graph TB';
                }
                
                document.getElementById('moto').innerHTML = mae_str+'\n'+output;
                window.myfunction();
            }

            // HTMLエスケープ用のヘルパーメソッド
            escapeHtml(unsafe) {
                return unsafe
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;");
            }

            // 新しいメソッド: テキストの書き出し

            addClearButton() {
                const clearButton = document.createElement('button');
                clearButton.textContent = '全グループ化解除';
                clearButton.addEventListener('click', () => this.clearAllHighlights());
                this.app.insertBefore(clearButton, this.app.firstChild);
            }

            addexportButton() {
                const exportButton = document.createElement('button');
                exportButton.textContent = 'csv保存';
                exportButton.addEventListener('click', () => this.exportCSV());
                this.app.insertBefore(exportButton, this.app.firstChild);
            }

            exportCSV() {
                const textareasData = [];
                
                // テキストエリアの内容とインデントを取得
                this.textareas.forEach((textareaDiv) => {
                    const textarea = textareaDiv.querySelector('textarea');
                    const indent = Math.floor(parseInt(textarea.style.marginLeft) / 20);
                    const content = textarea.value.replace(/\n/g, '\\n').trim(); // 改行をエスケープしてトリム
                    textareasData.push({ content, indent });
                });

                // CSV形式に変換
                const rows = textareasData.map(item => `${item.content},${item.indent}`);
                const csvContent = rows.join("\n");

                // ファイル名を入力要素から取得
                //const filename = this.getFilename() || 'textareas_data.csv';
                const filename = 'textareas_data.csv';

                // CSVファイルとして保存
                this.createDownloadLink(csvContent, filename);
            }

            /*
            getFilename() {
                // ファイル名を入力要素から取得
                const filenameInput = document.getElementById('filenameInput');
                return filenameInput ? filenameInput.value.trim() : '';
            }
            */

            createDownloadLink(content, filename) {
                // Blobオブジェクトを作成
                const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                
                // リンク要素を作成
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                link.style.visibility = 'hidden';
                
                // リンク要素をDOMに追加してクリック
                document.body.appendChild(link);
                link.click();
                
                // リンク要素をDOMから削除
                document.body.removeChild(link);
                URL.revokeObjectURL(url); // メモリを解放
            }


            createCSVFileInput() {
                const csvFileInput = document.createElement('input');
                csvFileInput.type = 'file';
                csvFileInput.id = 'csvFile';
                csvFileInput.accept = '.csv';
                csvFileInput.onchange = () => this.importCSV();
                
                // CSV ファイル入力要素を Clear ボタンの後に挿入
            //    this.app.insertBefore(csvFileInput, this.app.firstChild.nextSibling);
                this.app.insertBefore(csvFileInput, this.app.firstChild.nextSibling);
            }

            clearAllHighlights() {
                this.textareas.forEach(container => {
                    container.querySelector('textarea').style.backgroundColor = '';
                });
                //this.highlightedGroup = null;
            }

            createTextareaElement(indent = 0) {
                const container = document.createElement('div');
                container.className = 'textarea-container';

                const controls = document.createElement('div');
                controls.className = 'controls';

                const buttons = ['消', '←','→','↑','↓','たたむ', 'ひらく', 'G'];
                buttons.forEach(label => {
                    const button = document.createElement('button');
                    button.textContent = label;
                    button.addEventListener('click', () => this.handleButtonClick(label, container));
                    if (label === 'たたむ') {
                        button.classList.add('close-button');
                    }
                    if (label === 'ひらく') {
                        button.classList.add('open-button');
                    }
                    controls.appendChild(button);
                });

                const textareaWrapper = document.createElement('div');
                textareaWrapper.className = 'textarea-wrapper';

                const textarea = document.createElement('textarea');
                textarea.style.marginLeft = `${indent * 20}px`;
                textarea.rows = 1;
                textarea.addEventListener('input', this.handleInput.bind(this));
                textarea.addEventListener('keydown', this.handleKeyDown.bind(this));

                const textareaNumber = document.createElement('div');
                textareaNumber.className = 'textarea-number';

                textareaWrapper.appendChild(textarea);
                textareaWrapper.appendChild(textareaNumber);

                container.appendChild(controls);
                container.appendChild(textareaWrapper);

                return container;
            }

            handleInput(event) {
                this.autoResize(event);
            }

            autoResize(event) {
                const textarea = event.target;
                textarea.style.height = 'auto';
                textarea.style.height = (textarea.scrollHeight) + 'px';
            }

            updateTextareaNumbers() {
                this.textareas.forEach((container, index) => {
                    const textareaNumber = container.querySelector('.textarea-number');
                    textareaNumber.textContent = index;
                });
            }


            handleKeyDown(event) {
                const textarea = event.target;
                const container = textarea.closest('.textarea-container');
                const index = this.textareas.indexOf(container);
                let cindex=index;
 
                if (event.ctrlKey) {
                    if (event.key === 'ArrowUp') {
                        if (event.preventDefault && typeof event.preventDefault === 'function') {
                           event.preventDefault();
                        }
                        //★★★-----------------------------------------------------------------
                        //カーソルがあるのがハイライトされたテキストエリアの場合---
                        if (textarea.style.backgroundColor !== '') {
                            //そのブロックの一番上のインデックスを取得
                            let now_gpnum=this.getGroupNumber(this.textareas[index]);
                            const highlightedIndexes = this.getHighlightedIndexes();
                            while (highlightedIndexes.includes(cindex) && this.getGroupNumber(this.textareas[cindex])===now_gpnum) {
                                //カレントインデックスを減らしていく
                                cindex--;
                            }
                            // 一番上のindex
                            let firstHighlightedIndex=cindex+1;
                            //alert('自分のブロックの先頭'+firstHighlightedIndex);

                            //真上取得
                            const aboveContainer = this.textareas[firstHighlightedIndex - 1];
                            const aboveTextarea = aboveContainer.querySelector('textarea');
                            //alert('真上' +(firstHighlightedIndex - 1));

                            //真上がハイライトされている場合
                            if (aboveTextarea.style.backgroundColor !== '') {
                                //真上のハイライトされているテキストエリアの数を数える
                                let tcount=this.countGroupMembers(firstHighlightedIndex - 1);
                                //alert('真上のブロックの本数'+tcount);
                                //indexを減じながら、その数だけupを繰り返し、真上のブロックを超える
                                for(let i=0;i<tcount;i++){
                                    //alert((firstHighlightedIndex+i)+'を上げる');
                                    this.moveHighlightedUp(firstHighlightedIndex-i);
                                }
                            } else {
                                //真上がハイライトされていない場合
                                this.moveHighlightedUp(index);
                            }
                        //カーソルがあるのはハイライトされていないテキストエリアの場合    
                        } else {
                            //それがてっぺんのテキストエリアなら何もしない
                            if (index > 0) { 
                                // ２行使って、真上のテキストエリア取得
                                const aboveContainer = this.textareas[index - 1];
                                const aboveTextarea = aboveContainer.querySelector('textarea');
                                // 真上のテキストエリアがハイライトされている場合
                                if (aboveTextarea.style.backgroundColor !== '') {
                                    this.moveHighlightedDown((index-1)); 
                                    let textarea = event.target;
                                    let container = textarea.closest('.textarea-container');
                                    let cindex = this.textareas.indexOf(container);
                                    this.moveCursor(cindex,0); 
                                } else {
                                    //カーソル位置は現在のテキストエリア内のカーソル位置になる。
                                    const cursorPosition = textarea.selectionStart;
                                    //indexのテキストエリアが真上と入れ替わる
                                    this.swapWithAbove(index, cursorPosition);
                                }

                            }
                        }
                        //★★★-----------------------------------------------------------------

                    } else if (event.key === 'ArrowDown') {
                        if (event.preventDefault && typeof event.preventDefault === 'function') {
                           event.preventDefault();
                        }
                        //カーソルがあるのがハイライトされたテキストエリアの場合
                        if (textarea.style.backgroundColor !== '') {
                            //自身のハイライトされているテキストエリアの数を数える ２個
                            let tcount=this.countGroupMembers(index);
                            //alert('このブロックの本数'+tcount);
                            //自分のグループの真下取得　自分１＋２
                            const belowContainer = this.textareas[index + tcount];
                            const belowTextarea = belowContainer.querySelector('textarea');
                            //alert('真下' +(index + tcount));
                            //自分のグループの真下がハイライトされている場合
                            if (belowTextarea.style.backgroundColor !== '') {
                                //自分のブロックの一番上のインデックスを取得
                                let now_gpnum=this.getGroupNumber(this.textareas[index]);
                                const highlightedIndexes = this.getHighlightedIndexes();
                                while (highlightedIndexes.includes(cindex) && this.getGroupNumber(this.textareas[cindex])===now_gpnum) {
                                    //カレントインデックスを減らしていく
                                    cindex--;
                                }
                                // 一番上のindex
                                let firstHighlightedIndex=cindex+1;
                                //alert('自分のブロックの先頭'+firstHighlightedIndex);

                                //真下のハイライトされているテキストエリアの数を数える
                                let tcount2=this.countGroupMembers(index + tcount);
                                //alert('真下のブロックの本数'+tcount2);
                                //indexを増やしながら、真下のブロックを超える
                                for(let i=0;i<tcount2;i++){
                                    //alert((firstHighlightedIndex+i)+'を下げる');
                                    this.moveHighlightedDown(firstHighlightedIndex+i);
                                }
                            } else {
                                //真下がハイライトされていない場合
                                this.moveHighlightedDown(index);
                            }
                        //カーソルがあるのはハイライトされていないテキストエリアの場合    
                        } else {
                            //それが一番下のテキストエリアなら何もしない
                            if (index < this.textareas.length - 1) { 
                                // ２行使って、真下のテキストエリア取得
                                const belowContainer = this.textareas[index + 1];
                                const belowTextarea = belowContainer.querySelector('textarea');
                                //真下がハイライトされている場合
                                if (belowTextarea.style.backgroundColor !== '') {
                                    // カーソルをそのテキストエリアに移して、
                                    //そのテキストエリアを上にあげる
                                    //this.moveCursor(index+1,0);  
                                    this.moveHighlightedUp((index+1));
                                    
                                    const textarea = event.target;
                                    const container = textarea.closest('.textarea-container');
                                    let cindex = this.textareas.indexOf(container);
                                    this.moveCursor(cindex,0); 
                                } else {
                                    //カーソル位置は現在のテキストエリア内のカーソル位置になる。
                                    const cursorPosition = textarea.selectionStart;
                                    //indexのテキストエリアが真下と入れ替わる
                                    this.swapWithBelow(index, cursorPosition);
                                }
                            }
                        }
                    }   
                
                } else if (event.key === 'Enter' && !event.shiftKey) {
                    event.preventDefault();
                    const currentIndent = this.getIndent(container);
                    
                    const cursorPosition = textarea.selectionStart;
                    const currentText = textarea.value;
                    const newText = currentText.substring(cursorPosition);
                    textarea.value = currentText.substring(0, cursorPosition);

                    this.addTextarea(index + 1, currentIndent, newText);
                    
                    setTimeout(() => {
                        const newTextarea = this.textareas[index + 1].querySelector('textarea');
                        newTextarea.focus();
                        newTextarea.selectionStart = newTextarea.selectionEnd = 0;
                    }, 0);
                } else if (event.key === 'Tab') {
                    event.preventDefault();
                    const direction = event.shiftKey ? -1 : 1;
                    const cursorPosition = textarea.selectionStart;
                    this.shiftIndent(index, direction);
                    
                    setTimeout(() => {
                        const updatedTextarea = this.textareas[index].querySelector('textarea');
                        updatedTextarea.focus();
                        updatedTextarea.selectionStart = updatedTextarea.selectionEnd = cursorPosition;
                    }, 0);
                } else if (event.key === 'ArrowUp' && textarea.selectionStart === 0) {
                    this.moveCursor(index, -1);
                } else if (event.key === 'ArrowDown' && textarea.selectionStart === textarea.value.length) {
                    this.moveCursor(index, 1);
                }
            }
            
            //currentIndex: 現在のテキストエリアのインデックス。direction: 移動する方向。1なら次のテキストエリア、-1なら前のテキストエリア。
            moveCursor(currentIndex, direction) {
                //現在のインデックスに方向を加算して、移動先のインデックスを計算します。
                const targetIndex = currentIndex + direction;
                //ターゲットインデックスが有効な範囲内にあるかを確認します。
                if (targetIndex >= 0 && targetIndex < this.textareas.length) {
                    //ターゲットインデックスのテキストエリアを取得し、フォーカスを移動します。
                    const targetTextarea = this.textareas[targetIndex].querySelector('textarea');
                    targetTextarea.focus();
                    //directionが1の場合、カーソルをテキストエリアの先頭に移動します。
                    //directionが-1の場合、カーソルをテキストエリアの末尾に移動します。
                    if (direction === 1) {
                        targetTextarea.selectionStart = targetTextarea.selectionEnd = 0;
                    } else {
                        targetTextarea.selectionStart = targetTextarea.selectionEnd = targetTextarea.value.length;
                    }
                }
            }

            addTextarea(index = this.textareas.length, indent = 0, initialText = '') {
                const newTextarea = this.createTextareaElement(indent);
                const textarea = newTextarea.querySelector('textarea');
                const openButton = newTextarea.querySelector('.open-button');
                textarea.value = initialText;
                this.textareas.splice(index, 0, newTextarea);
                openButton.style.display = 'none';
                this.updateDOM();

            }

            addTextarea2(indent, initialText) {
                const index = this.textareas.length; 
                const newTextarea = this.createTextareaElement(indent);
                const textarea = newTextarea.querySelector('textarea');
                const openButton = newTextarea.querySelector('.open-button');
                textarea.value = initialText;
                this.textareas.splice(index, 0, newTextarea);
                openButton.style.display = 'none';
                this.updateDOM();

            }

            removeTextarea(index) {
                if (this.textareas.length > 1) {
                    this.textareas.splice(index, 1);
                    this.updateDOM();
                }
            }

            updateDOM() {
                this.app.innerHTML = '';
                this.addClearButton();
                this.textareas.forEach(textarea => {
                    this.app.appendChild(textarea);
                    const textareaElement = textarea.querySelector('textarea');
                    this.autoResize({target: textareaElement});
                });
                this.updateTextareaNumbers();
                this.updateCloseButtons();

                // 出力エリアとボタンを再作成
                this.addexportButton();
                this.createCSVFileInput();
                this.createOutputArea();
            }

            getIndent(element) {
                return parseInt(element.querySelector('textarea').style.marginLeft) / 20;
            }

            setIndent(element, indent) {
                element.querySelector('textarea').style.marginLeft = `${indent * 20}px`;
            }

            handleButtonClick(label, container) {
                const index = this.textareas.indexOf(container);
                const textarea = container.querySelector('textarea');
                let direction;
                let cursorPosition;

                switch (label) {
                    case '→':
                        direction = 1;
                        cursorPosition = textarea.selectionStart;
                        this.shiftIndent(index, direction);
                        
                        setTimeout(() => {
                            const updatedTextarea = this.textareas[index].querySelector('textarea');
                            updatedTextarea.focus();
                            updatedTextarea.selectionStart = updatedTextarea.selectionEnd = cursorPosition;
                        }, 0);                    
                        break;
                    case '←':
                        direction = -1;
                        cursorPosition = textarea.selectionStart;
                        this.shiftIndent(index, direction);
                        

                        setTimeout(() => {
                            const updatedTextarea = this.textareas[index].querySelector('textarea');
                            updatedTextarea.focus();
                            updatedTextarea.selectionStart = updatedTextarea.selectionEnd = cursorPosition;
                        }, 0);                    
                        break;
                    case '消':
                        this.removeTextarea(index);
                        break;
                    case 'たたむ':
                        //真上がないか、真上と異なるグループ番号の時だけ閉じられる
                        if( index === 0 ){
                            this.highlightGroup(index);
                            this.toggleVisibility(index, false);
                        } else {
                            if(this.getGroupNumber(this.textareas[index])!=this.getGroupNumber(this.textareas[index-1])){
                                this.highlightGroup(index);
                                this.toggleVisibility(index, false);
                            } else {
                                if (this.getGroupNumber(this.textareas[index])==0 ){
                                    this.highlightGroup(index);
                                    this.toggleVisibility(index, false);
                                } else {
                                    this.highlightGroupOff(index);
                                    this.highlightGroup(index);
                                    this.toggleVisibility(index, false);
                                }
                            }
                        }
                        break;
                    case 'ひらく':
                        
                        this.toggleVisibility(index, true);
                        break;
                    case 'G':
                        this.toggleHighlightGroup(index);
                        break;
                    case '↑':
                        this.handleKeyDown({
                            target: textarea,
                            ctrlKey: true,
                            key: 'ArrowUp',
                            preventDefault: () => {} // ダミーの preventDefault メソッド                            
                        });
                        break;
                    case '↓':
                        this.handleKeyDown({
                            target: textarea,
                            ctrlKey: true,
                            key: 'ArrowDown',
                            preventDefault: () => {} // ダミーの preventDefault メソッド                            
                        });
                        break;
                }
            }

            toggleHighlightGroup(index) {
                const highlightedIndexes = this.getHighlightedIndexes();
                if(highlightedIndexes.includes(index) ){
                    //this.clearHighlight();
                    //alert(1);
                    this.highlightGroupOff(index);
                } else {
                    //0707 this.clearHighlight();
                    this.highlightGroup(index);
                }
            }

            clearHighlight() {
                this.textareas.forEach(container => {
                    container.querySelector('textarea').style.backgroundColor = '';
                });
            }

            highlightGroupOff(index) {

                //そのindexのグループ番号を取得して
                //同じグループを解除する
                let g_num1=this.getGroupNumber(this.textareas[index]);
                //alert(g_num1);
                let g_num2;
                for(let i=0;i<this.textareas.length;i++){
                    g_num2=this.getGroupNumber(this.textareas[i]);
                    if(g_num2===g_num1){
                        this.textareas[i].querySelector('textarea').style.backgroundColor = '';
                        this.setGroupNumber(this.textareas[i], 0);
                    }
                }

                /*
                const startIndent = this.getIndent(this.textareas[index]);
                
                for (let i = index; i < this.textareas.length; i++) {
                    const currentIndent = this.getIndent(this.textareas[i]);
                    if (i === index || currentIndent > startIndent) {
                        this.textareas[i].querySelector('textarea').style.backgroundColor = '';
                        //yas
                        this.setGroupNumber(this.textareas[i], 0);
                    } else {
                        break;
                    }
                }
                */    
            }


            highlightGroup(index) {
                const startIndent = this.getIndent(this.textareas[index]);
                let newGroupNumber;
                
                //真下にテキストエリアがある場合
                if(index<(this.textareas.length-1)){
                    //真下のテキストエリアのインデントを取得
                    const nextIndent = this.getIndent(this.textareas[index+1]);
                    const nowIndent = this.getIndent(this.textareas[index]);
                    //真下のテキストエリアのインデントが自分より右にある場合はグループ化
                    if(nextIndent > nowIndent){
                        //このテキストエリアを取得
                        const nowContainer = this.textareas[index];
                        const nowTextarea = nowContainer.querySelector('textarea');
                        //このテキストエリアがすでにグループ番号を持っているなら
                        if (nowTextarea.style.backgroundColor !== '') {
                            //そのグループ番号を使う
                            newGroupNumber=this.getGroupNumber(this.textareas[index]);
                        } else {    
                            this.maxGroupNumber++;
                            newGroupNumber = this.maxGroupNumber;
                        }
                        this.updateMaxGroupNumberDisplay();

                        // 新しい背景色を取得
                        const backgroundColor = this.getBackgroundColor(newGroupNumber);

                        for (let i = index; i < this.textareas.length; i++) {
                            const currentIndent = this.getIndent(this.textareas[i]);
                            if (i === index || currentIndent > startIndent) {
                                this.textareas[i].querySelector('textarea').style.backgroundColor = backgroundColor;
                                this.setGroupNumber(this.textareas[i], newGroupNumber);                         
                            } else {
                                break;
                            }
                        }
                    }
                }

                //そのindexがブロック化済で
                //真上と違うグループ番号なら、そのグループ番号を使う。

            }

            // 新しい関数: グループ番号に基づいて背景色を返す
            getBackgroundColor(groupNumber) {
                // パステルカラーの配列
                const colors = [
                    '#FFD3E0', '#FFF0D3', '#D3FFD3', '#D3F0FF', '#E0D3FF',
                    '#FFE0D3', '#D3FFE0', '#D3E0FF', '#FFD3F0', '#F0FFD3'
                ];
                
                // グループ番号に基づいて色を選択（循環させる）
                return colors[(groupNumber % 10) % colors.length];
            }

            //yas
            getGroupNumber(container) {
                const textarea = container.querySelector('textarea');
                return parseInt(textarea.dataset.groupNumber || '0');
            }
            //yas
            setGroupNumber(container, number) {
                const textarea = container.querySelector('textarea');
                textarea.dataset.groupNumber = number.toString();
                const groupNumberDisplay = container.querySelector('.group-number-display');
                if (groupNumberDisplay) {
                    groupNumberDisplay.textContent = `グループ: ${number}`;
                }
            }
            //yas
            updateMaxGroupNumberDisplay() {
                this.groupNumberDisplay.textContent = `最大グループ番号: ${this.maxGroupNumber}`;
                this.groupNumberDisplay.style.visibility = 'hidden';
            }


            moveTextareas(index, direction, cursorPosition = null) {
                const newIndex = index + direction;

                if (newIndex < 0 || newIndex >= this.textareas.length) {
                    return false;
                }

                const temp = this.textareas[index];
                this.textareas[index] = this.textareas[newIndex];
                this.textareas[newIndex] = temp;

                this.updateDOM();

                const movedTextarea = this.textareas[newIndex].querySelector('textarea');
                movedTextarea.focus();
                if (cursorPosition !== null) {
                    movedTextarea.selectionStart = movedTextarea.selectionEnd = Math.min(cursorPosition, movedTextarea.value.length);
                }

                return true;
            }

            shiftIndent(startIndex, direction) {
                const startIndent = this.getIndent(this.textareas[startIndex]);
                let i = startIndex;

                while (i < this.textareas.length) {
                    const currentIndent = this.getIndent(this.textareas[i]);
                    if (i > startIndex && currentIndent <= startIndent) break;

                    const newIndent = Math.max(0, currentIndent + direction);
                    this.setIndent(this.textareas[i], newIndent);
                    i++;
                }

                this.updateDOM();
            }

            //showがtrueだと２つ目以降が表示、falseだと非表示になる
            toggleVisibility(startIndex, show) {
                // デバッグ用：開始インデックスをログ出力
                console.log(startIndex);

                // 開始要素のインデントレベルを取得
                const startIndent = this.getIndent(this.textareas[startIndex]);
                // 閉じるボタンのスタイルを更新

                //２つ目以降を処理
                let i = startIndex + 1;

                // 開始要素より深いインデントの要素を処理
                while (i < this.textareas.length) {
                    const currentIndent = this.getIndent(this.textareas[i]);
                    // 開始要素以下のインデントレベルになったら処理を終了
                    if (currentIndent <= startIndent) break;
                    
                    if(i===(startIndex + 1)){
                        let closeButton = this.textareas[startIndex].querySelector('.close-button');
                        let openButton = this.textareas[startIndex].querySelector('.open-button');
                        if (show===true) {
                            closeButton.style.display = '';
                            openButton.style.display = 'none';
                        } else {
                            closeButton.style.display = 'none';
                            openButton.style.display = '';
                        }
                    }
                    let closeButton = this.textareas[i].querySelector('.close-button');
                    let openButton = this.textareas[i].querySelector('.open-button');

                    // ２つ目以降を１つずつ表示（非表示）に  ※３つ目以降も非表示なら表示にってやってるからだめなんだ。非表示なのか、表示なのかは２つ目で決める！
                    if(show===true){
                        this.textareas[i].style.display='';
                        closeButton.style.display = '';
                        openButton.style.display = 'none';
                    } else {
                        this.textareas[i].style.display='none';
                        closeButton.style.display = 'none';
                        openButton.style.display = '';
                    }
                    i++;
                }

                // デバッグ用：処理後の開始インデックスをログ出力
                console.log(startIndex);

                // 表示に切り替える場合、遅延してフォーカスを設定
                setTimeout(() => {
                    const nowTextarea = this.textareas[startIndex].querySelector('textarea');
                    nowTextarea.focus();
                    this.moveCursor(startIndex, 0);
                    // カーソルを先頭に移動
                    nowTextarea.selectionStart = nowTextarea.selectionEnd = 0;
                }, 100); // 100msの遅延を追加


                // DOM更新処理を呼び出し
                this.updateDOM();
            }

            updateCloseButtons() {
                this.textareas.forEach((container, index) => {
                    const closeButton = container.querySelector('.close-button');
                    const startIndent = this.getIndent(container);
                    let i = index + 1;
                    let hasHiddenTextareas = false;

                    while (i < this.textareas.length) {
                        const currentIndent = this.getIndent(this.textareas[i]);
                        if (currentIndent <= startIndent) break;

                        if (this.textareas[i].style.display === 'none') {
                            hasHiddenTextareas = true;
                            break;
                        }
                        i++;
                    }

                });
            }

            //ブロックの中の任意のインデックスをもらって、ブロックの本数を返す
            countGroupMembers(cindex){
                
                // グループ番号の取得
                let now_gpnum=this.getGroupNumber(this.textareas[cindex]);
                // ハイライトされたテキストエリアのインデックスを取得する
                const highlightedIndexes = this.getHighlightedIndexes();
                
                //このブロックの先頭の把握
                let i=cindex;
                while (highlightedIndexes.includes(i) && this.getGroupNumber(this.textareas[i])===now_gpnum) {
                    //カレントインデックスを減らしていく
                    i--;
                }
                // 一番上のindex
                let first=i+1;
                //alert('first'+first);

                //このハイライトグループの最後尾の把握---------------------------------
                i=cindex;
                while (highlightedIndexes.includes(i) && this.getGroupNumber(this.textareas[i])===now_gpnum) {
                    //カレントインデックスを増やしていく
                    i++;
                }
                let last=i-1;
                // 本数の算出
                //alert('last'+last);
                //alert('本数'+(last-first+1));
                return (last-first+1);
            }


            //ハイライトされたグループの真上のハイライトされていないテキストエリアを
            //ハイライトされたグループの個数分下に下げる。            
            moveHighlightedUp(cindex,direction) {
                //このハイライトされたテキストエリアのグループ番号を取得する
                let now_gpnum=this.getGroupNumber(this.textareas[cindex]);
                // ハイライトされたテキストエリアのインデックスを取得する
                const highlightedIndexes = this.getHighlightedIndexes();

                //このハイライトグループの最後尾の把握---------------------------------
                    while (highlightedIndexes.includes(cindex) && this.getGroupNumber(this.textareas[cindex])===now_gpnum) {
                        //カレントインデックスを増やしていく
                        cindex++;
                    }
                    // 最終的なcindexの値を確認
                    let lastHighlightedIndex=cindex-1;

                //このハイライトグループの先頭の把握---------------------------------
                    cindex=lastHighlightedIndex
                    while (highlightedIndexes.includes(cindex) && this.getGroupNumber(this.textareas[cindex])===now_gpnum) {
                        //カレントインデックスを増やしていく
                        cindex--;
                    }
                    // 最終的なcindexの値を確認
                    let firstHighlightedIndex=cindex+1;

                // ハイライトされたテキストエリアの中で一番上のテキストエリアが１行目ではないことを確認する
                if (firstHighlightedIndex != 0) {
                    //ハイライトされた小集団の真上のハイライトされていないテキストエリアのインデックスを取得
                    let currentIndex = firstHighlightedIndex-1 ;
                    // ハイライトされていないカレントインデックスのテキストエリアを下に移動
                    for (let i = currentIndex; i < lastHighlightedIndex ; i++) {
                        // ハイライトされていないテキストエリアを上に(カーソル位置はテキストの先頭に)
                        this.swapWithBelow(i, 0); 
                    }
                    this.moveCursor(firstHighlightedIndex-1,0)
                }
            }

            //ハイライトされたグループの真下のハイライトされていないテキストエリアを
            //ハイライトされたグループの個数分上に上げる            
            moveHighlightedDown(cindex) {
                //このハイライトされたテキストエリアのグループ番号を取得する
                let now_gpnum=this.getGroupNumber(this.textareas[cindex]);
                // ハイライトされたテキストエリアのインデックスを取得する
                const highlightedIndexes = this.getHighlightedIndexes();

                //このハイライトグループの最後尾の把握---------------------------------
                while (highlightedIndexes.includes(cindex) && this.getGroupNumber(this.textareas[cindex])===now_gpnum) {
                    //カレントインデックスを増やしていく
                    cindex++;
                }
                // 最後尾
                let lastHighlightedIndex=cindex-1;

                //このハイライトグループの先頭の把握---------------------------------
                cindex=lastHighlightedIndex
                while (highlightedIndexes.includes(cindex) && this.getGroupNumber(this.textareas[cindex])===now_gpnum) {
                    //カレントインデックスを増やしていく
                    cindex--;
                }
                // 先頭
                let firstHighlightedIndex=cindex+1;

                // ハイライトされたテキストエリアの中で一番下のテキストエリアが最終行ではないことを確認する
                if (lastHighlightedIndex < this.textareas.length - 1) {
                    //ハイライトされた小集団の真下のハイライトされていないテキストエリアのインデックスを取得
                    let currentIndex = lastHighlightedIndex + 1;
                    // ハイライトされていないカレントインデックスのテキストエリアを上に移動
                    for (let i = currentIndex; i > firstHighlightedIndex ; i--) {
                        // ハイライトされていないテキストエリアを上に(カーソル位置はテキストの先頭に)
                        this.swapWithAbove(i, 0); 
                    }
                    this.moveCursor(firstHighlightedIndex+1,0)
                }
            }
            
            //indexのテキストエリアをindex-1（１つ上）のテキストエリアと入れ替える
            //テキストの先頭にカーソルを置きたい場合はcursorPositionは0にする
            //テキストエリアのどこにカーソルを置くか指定したないときはnullにする
            swapWithAbove(index, cursorPosition) {
                // 上に交換するテキストエリアがあることを確認する
                if (index > 0) {
                    console.log('下:', index);
                    console.log('上:', index-1);
                    const temp = this.textareas[index];

                    this.textareas[index] = this.textareas[index - 1];
                    this.textareas[index - 1] = temp; // 現在のテキストエリアを上のテキストエリアと交換する

                    this.updateDOM(); // DOM を更新して新しい順序を反映させる

                    const aboveTextarea = this.textareas[index - 1].querySelector('textarea');
                    aboveTextarea.focus(); // 移動したテキストエリアにフォーカスを設定する
                    if (cursorPosition !== null) {
                        //cursorPositionにカーソルを置く
                        aboveTextarea.selectionStart = aboveTextarea.selectionEnd = cursorPosition; 
                    }
                }
            }

            //indexのテキストエリアをindex+1（１つ下）のテキストエリアと入れ替える
            //テキストの先頭にカーソルを置きたい場合はcursorPositionは0にする
            //テキストエリアのどこにカーソルを置くか指定したないときはnullにする
            swapWithBelow(index, cursorPosition) {
                if (index < this.textareas.length - 1) { // 最後のテキストエリアではないことを確認する
                    const temp = this.textareas[index];
                    this.textareas[index] = this.textareas[index + 1];
                    this.textareas[index + 1] = temp;// 現在のテキストエリアを下のテキストエリアと交換する

                    this.updateDOM();

                    const belowTextarea = this.textareas[index + 1].querySelector('textarea');
                    belowTextarea.focus(); // 移動したテキストエリアにフォーカスを設定する
                    if (cursorPosition !== null) {
                        belowTextarea.selectionStart = belowTextarea.selectionEnd = cursorPosition;
                        // カーソル位置を保持する（指定されている場合）
                    }
                }
            }


            getHighlightedIndexes() {
                return this.textareas.map((container, index) => {
                    const textarea = container.querySelector('textarea');
                    if (textarea.style.backgroundColor !== '') {
                        return index;
                    }
                    return null;
                }).filter(index => index !== null);
            }
        
            importCSV() {
                window.location.reload();
                const file = document.getElementById('csvFile').files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const content = e.target.result;
                        const lines = content.split('\n');
                        lines.forEach(line => {
                            if (line.trim() !== '') {
                                const [text, indent] = line.split(',');
                                this.addTextarea2(parseInt(indent),text);
                            }
                        });
                        this.updateGrouping();
                        this.updateDOM();
                        // setTimeout を使用して、読み込み後にテキストエリアを削除
                    };
                    reader.readAsText(file);
                    setTimeout(() => {
                            this.removeTextarea(0);
                            this.updateDOM(); // 削除後に再度 DOM を更新
                        }, 100);                    

                }
            }        
        }

        new TextareaManager();
    </script>

</body>
</html>
