<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hierarchize text Application</title>
    <style>
        :root {
            --button-width: 30px;
            --button-height: 30px;
            --button-font-size: 20px;
            --controls-text-align: right;
            --controls-display: inline-block;
        }
        .file-input-container {
            display: flex;
            align-items: center;
        }

        .file-input-label {
            margin-right: 10px;
        }        
        .textarea-container {
            display: flex;
            flex-direction: column;
            /*width: 40%;*/
            /*max-width: 600px; 必要に応じて調整*/
            margin: 0 0;           
            flex-wrap: wrap;       /* ボタンを折り返す */
            justify-content: flex-start; /* 左寄せにする */
        }
        

        .textarea-wrapper {
            display: flex;
            flex-direction: column;
            /*margin-bottom: 10px;*/
        }

        .textarea-and-number-wrapper {
            display: flex;
            align-items: flex-start;
        }

        textarea {
            flex-grow: 1;
            font-size: 20px;
            min-height: 24px; /*必要に応じて調整*/
            border: 1px solid #ccc;
            /*padding: 5px;*/
        }

        .textarea-number {
            width: 30px; /*必要に応じて調整*/
            text-align: right;
            padding-right: 5px;
            flex-shrink: 0;
        }

        .controls {
            display: var(--controls-display);  /* ボタンをインラインブロックにする */
            margin-right: 10px;    /* ボタン間のマージンを設定 */
            text-align: var(--controls-text-align);
            /*display: flex;*/
            /*flex-wrap: wrap;*/
            /*gap: 5px;*/
        }

        .controls button {
            /*padding: 5px 10px;*/
            cursor: pointer;
        }

        .controls_button,.upcontrols{
            height: 30px;
            font-size: 20px;
            flex: 1;
            margin: 0 2px;
        }

        .controls_2_button {
            /*width: var(--button-width);*/
            height: var(--button-height);
            font-size: var(--button-font-size);
            /*justify-content: center;
            align-items: center;
            box-sizing: border-box;*/
        }        

        #moto {
            display: none;
        }
    </style>
    <script>
        function openInNewWindow() {
            // 現在のファイルのURLを取得
            const currentUrl = window.location.href;
            // 現在のファイルのディレクトリを取得
            const directory = currentUrl.substring(0, currentUrl.lastIndexOf('/'));
            // 新しいウィンドウで開くファイルのURLを生成
            const newUrl = directory + '/Hierarchize_text_readme.html';
            // 新しいウィンドウでファイルを開く
            window.open(newUrl, '_blank', 'width=800,height=600');
        }
        function changeButtonSize(increment) {
            const root = document.documentElement;
            const currentWidth = parseInt(getComputedStyle(root).getPropertyValue('--button-width'));
            const currentHeight = parseInt(getComputedStyle(root).getPropertyValue('--button-height'));
            const currentFontSize = parseInt(getComputedStyle(root).getPropertyValue('--button-font-size'));
            

            const newWidth = currentWidth + increment;
            const newHeight = currentHeight + increment;
            const newFontSize = currentFontSize + increment;

            root.style.setProperty('--button-width', newWidth + 'px');
            root.style.setProperty('--button-height', newHeight + 'px');
            root.style.setProperty('--button-font-size', newFontSize + 'px');

        }
    </script>
</head>
<body>
 ★★テキスト階層化アプリ★★      使い方は <a href="#" onclick="openInNewWindow(); return false;">こちら</a><br>

    <span class="upcontrols">
        <b>ソフトウエアキーボード：</b>
        <label>
            <input type="radio" name="keyboard-toggle" value="show" checked>
            表示
        </label>
        <label>
            <input type="radio" name="keyboard-toggle" value="hide">
            非表示
        </label>
    </span>
    <span class="upcontrols">
        <b>各テキストボックスのボタン：</b>
        <label>
            <input type="radio" name="button_display" value="right" checked>
            右寄せ表示
        </label>
        <label>
            <input type="radio" name="button_display" value="left" >
            左寄せ表示
        </label>
        <label>
            <input type="radio" name="button_display" value="none">
            非表示
        </label>
    </span>
    <span class="upcontrols">
        <b>矢印ボタン：</b>
        <button onclick="changeButtonSize(1)"  class="upcontrols">大きく</button>
        <button onclick="changeButtonSize(-1)"  class="upcontrols">小さく</button>
    </span>
    <br>
    <div id="app"></div>

<script>
        class TextareaManager {
            constructor() {
                this.app = document.getElementById('app');
                this.textareas = [];
                //output用
                this.outputArea = null;
                //this.highlightedGroup = null;
                this.addTextarea();
                //this.addClearButton();
                //this.addimportButton();
                //this.addexportButton();
                //this.createCSVFileInput();

                // yas01 グループ番号管理のための追加
                this.maxGroupNumber = 0;
                this.groupNumberDisplay = document.createElement('div');
                this.groupNumberDisplay.id = 'max-group-number';
                document.body.insertBefore(this.groupNumberDisplay, document.body.firstChild);
                this.updateMaxGroupNumberDisplay();  

                // 新しい出力エリアの追加
                //this.createOutputArea();
                
                this.radioButtons = document.querySelectorAll('input[name="keyboard-toggle"]');
                this.radioButtons.forEach(radio => {
                    radio.addEventListener('change', () => this.toggleReadonly());
                });
                // 初期状態を設定
                this.toggleReadonly();

                this.radioButtons = document.querySelectorAll('input[name="button_display"]');
                this.radioButtons.forEach(radio => {
                    radio.addEventListener('change', () => {
                        const selectedValue = document.querySelector('input[name="button_display"]:checked').value;
                        if (selectedValue === 'right') {
                            document.documentElement.style.setProperty('--controls-text-align', 'right');
                            document.documentElement.style.setProperty('--controls-display', 'inline-block');
                        } else if (selectedValue === 'left') {
                            document.documentElement.style.setProperty('--controls-text-align', 'left');
                            document.documentElement.style.setProperty('--controls-display', 'inline-block');
                        } else if (selectedValue === 'none') {
                            document.documentElement.style.setProperty('--controls-display', 'none');
                        }
                    });                
                });        

            }

            toggleReadonly() {
                const selectedValue = document.querySelector('input[name="keyboard-toggle"]:checked').value;
                const isReadonly = selectedValue === 'hide';

                this.textareas.forEach(textareaDiv => {
                    const textarea = textareaDiv.querySelector('textarea');
                    if (isReadonly) {
                        textarea.setAttribute('readonly', 'readonly');
                    } else {
                        textarea.removeAttribute('readonly');
                    }
                });
            }
       
            // 新しいメソッド: 出力エリアの作成
            createOutputArea() {

                this.outputArea = document.createElement('div');
                this.outputArea.id = 'output-area';
                //this.outputArea.contentEditable = true; // リッチテキストの編集を可能にする
                this.outputArea.style.border = '1px solid #ccc';
                this.outputArea.style.padding = '10px';
                this.outputArea.style.marginTop = '20px';
                this.outputArea.style.minHeight = '100px';
                this.outputArea.style.fontFamily = 'monospace'; // 等幅フォントを使用
                this.outputArea.style.display = 'none'; // 初期状態で非表示
                

                const outputButton = document.createElement('button');
                outputButton.className = 'upcontrols';
                outputButton.textContent = 'word文書として保存';
                outputButton.onclick = () => this.writeOutput();
                
                const outputButton2 = document.createElement('button');
                outputButton2.className = 'upcontrols';
                outputButton2.textContent = '左→右のツリーを生成';
                outputButton2.onclick = () => this.writeOutput4(1);

                const outputButton2_2 = document.createElement('button');
                outputButton2_2.className = 'upcontrols';
                outputButton2_2.textContent = '上→下のツリーを生成';
                outputButton2_2.onclick = () => this.writeOutput4(2);

                const outputButton3 = document.createElement('button');
                outputButton3.className = 'upcontrols';
                outputButton3.textContent = 'マインドマップを生成';
                outputButton3.onclick = () => this.writeOutput3();

                this.app.appendChild(outputButton);
                this.app.appendChild(outputButton2);
                this.app.appendChild(outputButton2_2);
                this.app.appendChild(outputButton3);

                this.app.appendChild(this.outputArea);
            }

            writeOutput3() {
                let output = '';
                const textareasData = [];
                let tmp;
                this.textareas.forEach(textareaDiv => {
                    const textarea = textareaDiv.querySelector('textarea');
                    const indent = Math.floor(parseInt(textarea.style.marginLeft) / 20);
                    const spaces = ' '.repeat(indent);
                    if(textarea.value.slice(0,1)==='+'){
                        tmp=textarea.value.slice(1);
                    } else {
                        tmp=textarea.value;
                    }

                    const escapedText = spaces+tmp+'\n';
                    
                    output += escapedText;
                    
                });

                //this.outputArea.innerHTML = output;
                document.getElementById('moto').innerHTML = 'mindmap\n'+output;
                window.myfunction();
                document.getElementById('neko1').style.display='';
                document.getElementById('neko2').style.display='';
            }


            old_writeOutput() {
                let output = '';
                this.textareas.forEach(textareaDiv => {
                    const textarea = textareaDiv.querySelector('textarea');
                    const indent = Math.floor(parseInt(textarea.style.marginLeft) / 20);
                    const indentPx = indent * 20;
                    
                    const escapedText = this.escapeHtml(textarea.value).replace(/\n/g, '<br>');
                    /*
                    output += `<blockquote style="margin-left: ${indentPx}px; padding-left: 10px; line-height: 1.3;">
                        ${escapedText}
                    </blockquote>`;
                    */
                    
                    output += `<blockquote style="margin-left: ${indentPx}px; padding-left: 10px; line-height: 1.3;">
                        <ul><li>${escapedText}</ul>
                    </blockquote>`;
                    
                });
                this.outputArea.innerHTML = output;
                if (output.trim() !== "") {
                    this.outputArea.style.display = 'block';
                } else {
                    this.outputArea.style.display = 'none';
                }
            }

            writeOutput() {
                let output =  '{\\rtf1\\ansi\\deff0 {\\fonttbl{\\f0 Times New Roman;}}\n';
                this.textareas.forEach(textareaDiv => {
                    const textarea = textareaDiv.querySelector('textarea');
                    const indent = Math.floor(parseInt(textarea.style.marginLeft) / 20);
                    const indentPx = indent * 210;
                    
                    output += `{\\pard\\li${indentPx} ` + this.escapeRTF(textarea.value) + '\\par\\par}\n';
                });
                output += '}'
                this.downloadRTF(output, 'outline.doc')
            }

            escapeRTF(text) {
                return text.replace(/[\\{}]/g, '\\$&')
                        .replace(/\n/g, '\\par ')
                        .replace(/[^\u0000-\u007F]/g, char => '\\u' + char.charCodeAt(0) + '?');
            }

            downloadRTF(content, filename) {
                const blob = new Blob([content], { type: 'application/rtf' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.click();
                URL.revokeObjectURL(link.href);
            }

            // 新しいメソッド: テキストの書き出し
            writeOutput2(num) {
                let output = '';
                const textareasData = [];
                
                // アルファベットの呼び名を生成する関数
                const generateAlphabetLabel = (index) => {
                    let label = '';
                    while (index >= 0) {
                        label = String.fromCharCode((index % 26) + 65) + label;
                        index = Math.floor(index / 26) - 1;
                    }
                    return label;
                };

                // テキストエリアの内容を収集
                this.textareas.forEach((textareaDiv, index) => {
                    const textarea = textareaDiv.querySelector('textarea');
                    const indent = Math.floor(parseInt(textarea.style.marginLeft) / 20);
                    const content = this.escapeHtml(textarea.value).replace(/\n/g, '<br>');
                    const label = generateAlphabetLabel(index);
                    textareasData.push({ label, content, indent });
                });

                // 関連付けと出力の生成
                for (let i = 1; i < textareasData.length; i++) {
                    const current = textareasData[i];
                    if (current.indent > 0) {
                        let relatedLabel = '';
                        for (let j = i - 1; j >= 0; j--) {
                            if (textareasData[j].indent < current.indent) {
                                relatedLabel = textareasData[j].label;
                                //output += `${relatedLabel}[${textareasData[j].content}]---${current.label}[${current.content}]<br>`;
                                output += `${relatedLabel}[${textareasData[j].content}]---${current.label}[${current.content}]\n`;
                                break;
                            }
                        }
                    }
                }

                //this.outputArea.innerHTML = output;
                let mae_str;
                if(num===1){
                    mae_str='graph LR';
                } else{
                    mae_str='graph TB';
                }
                
                document.getElementById('moto').innerHTML = mae_str+'\n'+output;
                window.myfunction();

            }

            writeOutput4(num){ 
                let output = '';
                const textareasData = [];
                let temp;
                
                // アルファベットの呼び名を生成する関数
                const generateAlphabetLabel = (index) => {
                    let label = '';
                    while (index >= 0) {
                        label = String.fromCharCode((index % 26) + 65) + label;
                        index = Math.floor(index / 26) - 1;
                    }
                    return label;
                };

                // テキストエリアの内容を収集
                this.textareas.forEach((textareaDiv, index) => {
                    const textarea = textareaDiv.querySelector('textarea');
                    const indent = Math.floor(parseInt(textarea.style.marginLeft) / 20);
                    const content = this.escapeHtml(textarea.value).replace(/\n/g, '<br>');
                    const label = generateAlphabetLabel(index);
                    textareasData.push({ label, content, indent });
                });


                // 関連付けと出力の生成
                for (let i = 0; i < textareasData.length; i++) {
                    const current = textareasData[i];
                    temp=current.content;
                    if(temp.slice(0,1)==='+'){
                        temp=temp.slice(1);
                    }
                    output += `${current.label}[${temp}]\n`;
                }

                // 関連付けと出力の生成
                for (let i = 1; i < textareasData.length; i++) {
                    const current = textareasData[i];
                    if (current.indent > 0) {
                        let relatedLabel = '';
                        for (let j = i - 1; j >= 0; j--) {
                            if (textareasData[j].indent < current.indent) {
                                if(textareasData[j].content.slice(0,1)==='+'){
                                    let k=j;
                                    relatedLabel=textareasData[k].label;
                                    while(textareasData[k].content.slice(0,1)==='+' && k > 0){
                                        relatedLabel = textareasData[k-1].label +' & ' + relatedLabel;
                                        k--;                                    
                                    }
                                } else {   
                                    relatedLabel = textareasData[j].label;
                                }
                                output += `${relatedLabel}---${current.label}\n`;
                                break;
                            }
                        }
                    }
                }

                //this.outputArea.innerHTML = output;
                let mae_str;
                if(num===1){
                    mae_str='graph LR';
                } else{
                    mae_str='graph TB';
                }
                
                document.getElementById('moto').innerHTML = mae_str+'\n'+output;
                window.myfunction();
                document.getElementById('neko1').style.display='';
                document.getElementById('neko2').style.display='';

            }

            // HTMLエスケープ用のヘルパーメソッド
            escapeHtml(unsafe) {
                return unsafe
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;");
            }

            // 新しいメソッド: テキストの書き出し

            addClearButton() {
                const clearButton = document.createElement('button');
                clearButton.textContent = '全グループ化解除';
                clearButton.className = 'upcontrols';
                clearButton.addEventListener('click', () => this.clearAllHighlights());
                this.app.appendChild(clearButton);
            }

            addexportButton() {
                const exportButton = document.createElement('button');
                exportButton.textContent = 'csvファイルに保存する';
                exportButton.className = 'upcontrols';
                exportButton.addEventListener('click', () => this.exportCSV());
                this.app.appendChild(exportButton);
            }

            exportCSV() {
                const textareasData = [];
                
                // テキストエリアの内容とインデントを取得
                this.textareas.forEach((textareaDiv) => {
                    const textarea = textareaDiv.querySelector('textarea');
                    const indent = Math.floor(parseInt(textarea.style.marginLeft) / 20);
                    const content = textarea.value.replace(/\n/g, '\\n').trim(); // 改行をエスケープしてトリム
                    textareasData.push({ content, indent });
                });

                // CSV形式に変換
                const rows = textareasData.map(item => `${item.content},${item.indent}`);
                const csvContent = rows.join("\n");

                // ファイル名を入力要素から取得
                //const filename = this.getFilename() || 'textareas_data.csv';
                const filename = 'textareas_data.csv';

                // CSVファイルとして保存
                this.createDownloadLink(csvContent, filename);
            }

            /*
            getFilename() {
                // ファイル名を入力要素から取得
                const filenameInput = document.getElementById('filenameInput');
                return filenameInput ? filenameInput.value.trim() : '';
            }
            */

            createDownloadLink(content, filename) {
                // Blobオブジェクトを作成
                const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                
                // リンク要素を作成
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                link.style.visibility = 'hidden';
                
                // リンク要素をDOMに追加してクリック
                document.body.appendChild(link);
                link.click();
                
                // リンク要素をDOMから削除
                document.body.removeChild(link);
                URL.revokeObjectURL(url); // メモリを解放
            }

            createCSVlabel() {
                const csvfileinputlabel = document.createElement('label');
                csvfileinputlabel.textContent = '保存したファイルを読み込む→(';
                csvfileinputlabel.className = 'upcontrols'; // スタイリング用のクラスを追加（オプション）
                this.app.appendChild(csvfileinputlabel);
            }

            createCSVFileInput() {
                const csvFileInput = document.createElement('input');
                csvFileInput.className = 'upcontrols';
                csvFileInput.type = 'file';
                csvFileInput.id = 'csvFile';
                csvFileInput.accept = '.csv';
                csvFileInput.onchange = () => this.importCSV();

                this.app.appendChild(csvFileInput);
            }

            createCSVlabel2() {
                const csvfileinputlabel2 = document.createElement('label');
                csvfileinputlabel2.textContent = '）';
                csvfileinputlabel2.className = 'upcontrols'; // スタイリング用のクラスを追加（オプション）
                this.app.appendChild(csvfileinputlabel2);
            }

            clearAllHighlights() {
                this.textareas.forEach(container => {
                    container.querySelector('textarea').style.backgroundColor = '';
                });
                //this.highlightedGroup = null;
            }

            createTextareaElement(indent = 0) {
                const container = document.createElement('div');
                container.className = 'textarea-container';

                const textareaWrapper = document.createElement('div');
                textareaWrapper.className = 'textarea-wrapper';

                const textareaAndNumberWrapper = document.createElement('div');
                textareaAndNumberWrapper.className = 'textarea-and-number-wrapper';

                const textarea = document.createElement('textarea');
                textarea.style.marginLeft = `${indent * 20}px`;
                textarea.rows = 1;
                textarea.addEventListener('input', this.handleInput.bind(this));
                textarea.addEventListener('keydown', this.handleKeyDown.bind(this));

                const textareaNumber = document.createElement('div');
                textareaNumber.className = 'textarea-number';

                textareaAndNumberWrapper.appendChild(textarea); 
                textareaAndNumberWrapper.appendChild(textareaNumber);
                textareaWrapper.appendChild(textareaAndNumberWrapper);

                const controls_A = document.createElement('div');
                controls_A.className = 'controls';
                controls_A.style.marginLeft = `${indent * 20}px`; // 初期設定
                controls_A.setAttribute('data-indent', indent); // indentを属性として保存
                controls_A.style.marginLeft = `${indent * 20}px`;
                const buttonsA = ['消', '畳む', '開く', 'G','↑','↓','←','→'];
                buttonsA.forEach(label => {
                    const button = document.createElement('button');
                    button.textContent = label;
                    button.addEventListener('click', () => this.handleButtonClick(label, container));
                    
                    if (label === '畳む') {
                        button.classList.add('close-button');
                    }
                    if (label === '開く') {
                        button.classList.add('open-button');
                    }
                    if (buttonsA.indexOf(label) >= 4) {
                        button.classList.add('controls_2_button');
                    } else {
                        button.classList.add('controls_button');
                    }
                    controls_A.appendChild(button);
                });

                container.appendChild(textareaWrapper);
                container.appendChild(controls_A);

                return container;
            }


             backup_createTextareaElement(indent = 0) {
                const container = document.createElement('div');
                container.className = 'textarea-container';

                const controls_A = document.createElement('div');
                controls_A.className = 'controls';
                const buttonsA = ['消', '畳む', '開く', 'G'];
                buttonsA.forEach(label => {
                    const button = document.createElement('button');
                    button.textContent = label;
                    button.addEventListener('click', () => this.handleButtonClick(label, container));
                    if (label === '畳む') {
                        button.classList.add('close-button');
                    }
                    if (label === '開く') {
                        button.classList.add('open-button');
                    }
                    controls_A.appendChild(button);
                });

                const controls_B = document.createElement('div');
                controls_B.className = 'controls_2';
                const buttonsB = ['←','→'];
                buttonsB.forEach(label => {
                    const button = document.createElement('button');
                    button.textContent = label;
                    button.addEventListener('click', () => this.handleButtonClick(label, container));
                    controls_B.appendChild(button);
                });

                const controls_C = document.createElement('div');
                controls_C.className = 'controls_2';
                const buttonsC = ['↑','↓'];
                buttonsC.forEach(label => {
                    const button = document.createElement('button');
                    button.textContent = label;
                    button.addEventListener('click', () => this.handleButtonClick(label, container));
                    controls_C.appendChild(button);
                });

                const textareaWrapper = document.createElement('div');
                textareaWrapper.className = 'textarea-wrapper';

                const textarea = document.createElement('textarea');
                textarea.style.marginLeft = `${indent * 20}px`;
                textarea.rows = 1;
                textarea.addEventListener('input', this.handleInput.bind(this));
                textarea.addEventListener('keydown', this.handleKeyDown.bind(this));

                const textareaNumber = document.createElement('div');
                textareaNumber.className = 'textarea-number';

                textareaWrapper.appendChild(textarea);

                container.appendChild(controls_A);
                container.appendChild(textareaWrapper);
                container.appendChild(textareaNumber);
                container.appendChild(controls_C);
                container.appendChild(controls_B);

                return container;
            }

            bcreateTextareaElement(indent = 0) {
                const container = document.createElement('div');
                container.className = 'textarea-container';

                const textareaWrapper = document.createElement('div');
                textareaWrapper.className = 'textarea-wrapper';

                const textarea = document.createElement('textarea');
                textarea.style.marginLeft = `${indent * 20}px`;
                textarea.rows = 1;
                textarea.addEventListener('input', this.handleInput.bind(this));
                textarea.addEventListener('keydown', this.handleKeyDown.bind(this));

                textareaWrapper.appendChild(textarea);

                const controlsWrapper = document.createElement('div');
                controlsWrapper.className = 'controls-wrapper';
                controlsWrapper.style.marginLeft = `${indent * 20}px`;

                const textareaNumber = document.createElement('div');
                textareaNumber.className = 'textarea-number';
                textareaNumber.textContent = '1'; // 仮の番号

                const controls = this.createControls(['消', '畳む', '開く', 'G', '↑', '↓', '←', '→'], 'controls');

                controlsWrapper.appendChild(textareaNumber);
                controlsWrapper.appendChild(controls);

                container.appendChild(textareaWrapper);
                container.appendChild(controlsWrapper);

                return container;
            }

            bcreateControls(buttons, className) {
                const controls = document.createElement('div');
                controls.className = className;
                buttons.forEach(label => {
                    const button = document.createElement('button');
                    button.textContent = label;
                    button.addEventListener('click', () => this.handleButtonClick(label, controls.parentElement.parentElement));
                    if (label === '畳む') {
                        button.classList.add('close-button');
                    }
                    if (label === '開く') {
                        button.classList.add('open-button');
                    }
                    controls.appendChild(button);
                });
                return controls;
            }

            handleInput(event) {
                    this.autoResize(event);
            }

            autoResize(event) {
                const textarea = event.target;
                textarea.style.height = 'auto';
                textarea.style.height = (textarea.scrollHeight) + 'px';
            }

            updateTextareaNumbers() {
                this.textareas.forEach((container, index) => {
                    const textareaNumber = container.querySelector('.textarea-number');
                    textareaNumber.textContent = index;
                });
            }


            handleKeyDown(event) {
                const textarea = event.target;
                const container = textarea.closest('.textarea-container');
                const index = this.textareas.indexOf(container);
                let cindex=index;
 
                if (event.ctrlKey) {
                    if (event.key === 'ArrowUp') {
                        if (event.preventDefault && typeof event.preventDefault === 'function') {
                           event.preventDefault();
                        }

                        //★★★-----------------------------------------------------------------
                        //カーソルがあるのがハイライトされたテキストエリアの場合---
                        if (textarea.style.backgroundColor !== '') {
                            //そのブロックの一番上のインデックスを取得
                            let now_gpnum=this.getGroupNumber(this.textareas[index]);
                            const highlightedIndexes = this.getHighlightedIndexes();
                            while (highlightedIndexes.includes(cindex) && this.getGroupNumber(this.textareas[cindex])===now_gpnum) {
                                //カレントインデックスを減らしていく
                                cindex--;
                            }
                            // 一番上のindex
                            let firstHighlightedIndex=cindex+1;
                            //alert('自分のブロックの先頭'+firstHighlightedIndex);

                            //真上取得
                            const aboveContainer = this.textareas[firstHighlightedIndex - 1];
                            const aboveTextarea = aboveContainer.querySelector('textarea');
                            //alert('真上' +(firstHighlightedIndex - 1));

                            //真上がハイライトされている場合
                            if (aboveTextarea.style.backgroundColor !== '') {
                                //真上のハイライトされているテキストエリアの数を数える
                                let tcount=this.countGroupMembers(firstHighlightedIndex - 1);
                                //alert('真上のブロックの本数'+tcount);
                                //indexを減じながら、その数だけupを繰り返し、真上のブロックを超える
                                for(let i=0;i<tcount;i++){
                                    //alert((firstHighlightedIndex+i)+'を上げる');
                                    this.moveHighlightedUp(firstHighlightedIndex-i);
                                }
                            } else {
                                //真上がハイライトされていない場合
                                this.moveHighlightedUp(index);
                            }
                        
                        
                            //カーソルがあるのはハイライトされていないテキストエリアの場合    
                        } else {
                            //それがてっぺんのテキストエリアなら何もしない
                            if (index > 0) { 
                                // ２行使って、真上のテキストエリア取得
                                const aboveContainer = this.textareas[index - 1];
                                const aboveTextarea = aboveContainer.querySelector('textarea');
                                // 真上のテキストエリアがハイライトされている場合
                                if (aboveTextarea.style.backgroundColor !== '') {
                                    this.moveHighlightedDown((index-1)); 
                                    let textarea = event.target;
                                    let container = textarea.closest('.textarea-container');
                                    let cindex = this.textareas.indexOf(container);
                                    this.moveCursor(cindex,0); 
                                } else {
                                    //カーソル位置は現在のテキストエリア内のカーソル位置になる。
                                    const cursorPosition = textarea.selectionStart;
                                    //indexのテキストエリアが真上と入れ替わる
                                    this.swapWithAbove(index, cursorPosition);
                                }

                            }
                        }
                        //★★★-----------------------------------------------------------------

                    } else if (event.key === 'ArrowDown') {
                        if (event.preventDefault && typeof event.preventDefault === 'function') {
                           event.preventDefault();
                        }
                        //カーソルがあるのがハイライトされたテキストエリアの場合
                        if (textarea.style.backgroundColor !== '') {
                            //自身のハイライトされているテキストエリアの数を数える ２個
                            let tcount=this.countGroupMembers(index);
                            //alert('このブロックの本数'+tcount);
                            //自分のグループの真下取得　自分１＋２
                            const belowContainer = this.textareas[index + tcount];
                            const belowTextarea = belowContainer.querySelector('textarea');
                            //alert('真下' +(index + tcount));
                            //自分のグループの真下がハイライトされている場合
                            if (belowTextarea.style.backgroundColor !== '') {
                                //自分のブロックの一番上のインデックスを取得
                                let now_gpnum=this.getGroupNumber(this.textareas[index]);
                                const highlightedIndexes = this.getHighlightedIndexes();
                                while (highlightedIndexes.includes(cindex) && this.getGroupNumber(this.textareas[cindex])===now_gpnum) {
                                    //カレントインデックスを減らしていく
                                    cindex--;
                                }
                                // 一番上のindex
                                let firstHighlightedIndex=cindex+1;
                                //alert('自分のブロックの先頭'+firstHighlightedIndex);

                                //真下のハイライトされているテキストエリアの数を数える
                                let tcount2=this.countGroupMembers(index + tcount);
                                //alert('真下のブロックの本数'+tcount2);
                                //indexを増やしながら、真下のブロックを超える
                                for(let i=0;i<tcount2;i++){
                                    //alert((firstHighlightedIndex+i)+'を下げる');
                                    this.moveHighlightedDown(firstHighlightedIndex+i);
                                }
                            } else {
                                //真下がハイライトされていない場合
                                this.moveHighlightedDown(index);
                            }
                        //カーソルがあるのはハイライトされていないテキストエリアの場合    
                        } else {
                            //それが一番下のテキストエリアなら何もしない
                            if (index < this.textareas.length - 1) { 
                                // ２行使って、真下のテキストエリア取得
                                const belowContainer = this.textareas[index + 1];
                                const belowTextarea = belowContainer.querySelector('textarea');
                                //真下がハイライトされている場合
                                if (belowTextarea.style.backgroundColor !== '') {
                                    // カーソルをそのテキストエリアに移して、
                                    //そのテキストエリアを上にあげる
                                    //this.moveCursor(index+1,0);  
                                    this.moveHighlightedUp((index+1));
                                    
                                    const textarea = event.target;
                                    const container = textarea.closest('.textarea-container');
                                    let cindex = this.textareas.indexOf(container);
                                    this.moveCursor(cindex,0); 
                                } else {
                                    //カーソル位置は現在のテキストエリア内のカーソル位置になる。
                                    const cursorPosition = textarea.selectionStart;
                                    //indexのテキストエリアが真下と入れ替わる
                                    this.swapWithBelow(index, cursorPosition);
                                }
                            }
                        }
                    }   
                
                } else if (event.key === 'Enter' && !event.shiftKey) {
                    event.preventDefault();
                    const currentIndent = this.getIndent(container);
                    
                    const cursorPosition = textarea.selectionStart;
                    const currentText = textarea.value;
                    const newText = currentText.substring(cursorPosition);
                    textarea.value = currentText.substring(0, cursorPosition);

                    this.addTextarea(index + 1, currentIndent, newText);
                    
                    setTimeout(() => {
                        const newTextarea = this.textareas[index + 1].querySelector('textarea');
                        newTextarea.focus();
                        newTextarea.selectionStart = newTextarea.selectionEnd = 0;
                    }, 0);
                } else if (event.key === 'Tab') {
                    event.preventDefault();
                    const direction = event.shiftKey ? -1 : 1;
                    const cursorPosition = textarea.selectionStart;
                    this.shiftIndent(index, direction);
                    
                    //ipad用にupdatedTextarea.selectionStart = updatedTextarea.selectionEnd = cursorPosition;をsettimeoutで包んだ
                    setTimeout(() => {
                        const updatedTextarea = this.textareas[index].querySelector('textarea');
                        updatedTextarea.focus();
                        setTimeout(() => {
                            updatedTextarea.selectionStart = updatedTextarea.selectionEnd = cursorPosition;
                        },0);
                    }, 0);
                } else if (event.key === 'ArrowUp' && textarea.selectionStart === 0) {
                    this.moveCursor(index, -1);
                } else if (event.key === 'ArrowDown' && textarea.selectionStart === textarea.value.length) {
                    this.moveCursor(index, 1);
                }
            }
            
            //currentIndex: 現在のテキストエリアのインデックス。direction: 移動する方向。1なら次のテキストエリア、-1なら前のテキストエリア。
            moveCursor(currentIndex, direction) {
                //現在のインデックスに方向を加算して、移動先のインデックスを計算します。
                const targetIndex = currentIndex + direction;
                //ターゲットインデックスが有効な範囲内にあるかを確認します。
                if (targetIndex >= 0 && targetIndex < this.textareas.length) {
                    //ターゲットインデックスのテキストエリアを取得し、フォーカスを移動します。
                    const targetTextarea = this.textareas[targetIndex].querySelector('textarea');
                    targetTextarea.focus();
                    //directionが1の場合、カーソルをテキストエリアの先頭に移動します。
                    //directionが-1の場合、カーソルをテキストエリアの末尾に移動します。
                    if (direction === 1) {
                        targetTextarea.selectionStart = targetTextarea.selectionEnd = 0;
                    } else {
                        targetTextarea.selectionStart = targetTextarea.selectionEnd = targetTextarea.value.length;
                    }
                }
            }

            addTextarea(index = this.textareas.length, indent = 0, initialText = '') {
                const newTextarea = this.createTextareaElement(indent);
                const textarea = newTextarea.querySelector('textarea');
                const openButton = newTextarea.querySelector('.open-button');
                textarea.value = initialText;
                this.textareas.splice(index, 0, newTextarea);
                openButton.style.display = 'none';
                this.updateDOM();

            }

            addTextarea2(indent, initialText) {
                const index = this.textareas.length; 
                const newTextarea = this.createTextareaElement(indent);
                const textarea = newTextarea.querySelector('textarea');
                const openButton = newTextarea.querySelector('.open-button');
                textarea.value = initialText;
                this.textareas.splice(index, 0, newTextarea);
                openButton.style.display = 'none';
                this.updateDOM();

            }

            removeTextarea(index) {
                if (this.textareas.length > 1) {
                    this.textareas.splice(index, 1);
                    this.updateDOM();
                }
            }

            updateDOM() {
                this.app.innerHTML = '';
                this.createCSVlabel();
                this.createCSVFileInput();
                this.createCSVlabel2();
                this.addexportButton();
                this.addClearButton();
                this.textareas.forEach(textarea => {
                    this.app.appendChild(textarea);
                    const textareaElement = textarea.querySelector('textarea');
                    this.autoResize({target: textareaElement});
                });
                this.updateTextareaNumbers();
                this.updateCloseButtons();

                // 出力エリアとボタンを再作成
                this.createOutputArea();
            }

            getIndent(element) {
                return parseInt(element.querySelector('textarea').style.marginLeft) / 20;
            }

            setIndent(element, indent) {
                element.querySelector('textarea').style.marginLeft = `${indent * 20}px`;
                // controls_Aのインデントを設定
                const controlsA = element.querySelector('.controls');
                if (controlsA) {
                    controlsA.style.marginLeft = `${indent * 20}px`;
                    controlsA.setAttribute('data-indent', indent); // indentを属性として保存
                }
            }

            handleButtonClick(label, container) {
                const index = this.textareas.indexOf(container);
                const textarea = container.querySelector('textarea');
                let direction;
                let cursorPosition;
                let cindex=index;

                switch (label) {
                    case '→':
                        direction = 1;
                        cursorPosition = textarea.selectionStart;
                        this.shiftIndent(index, direction);
                        
                        setTimeout(() => {
                            const updatedTextarea = this.textareas[index].querySelector('textarea');
                            updatedTextarea.focus();
                            updatedTextarea.selectionStart = updatedTextarea.selectionEnd = cursorPosition;
                        }, 0);                    
                        break;
                    case '←':
                        direction = -1;
                        cursorPosition = textarea.selectionStart;
                        this.shiftIndent(index, direction);
                        

                        setTimeout(() => {
                            const updatedTextarea = this.textareas[index].querySelector('textarea');
                            updatedTextarea.focus();
                            updatedTextarea.selectionStart = updatedTextarea.selectionEnd = cursorPosition;
                        }, 0);                    
                        break;
                    case '消':
                        this.removeTextarea(index);
                        break;
                    case '畳む':
                        //真上がないか、真上と異なるグループ番号の時だけ閉じられる
                        if( index === 0 ){
                            this.highlightGroup(index);
                            this.toggleVisibility(index, false);
                        } else {
                            if(this.getGroupNumber(this.textareas[index])!=this.getGroupNumber(this.textareas[index-1])){
                                this.highlightGroup(index);
                                this.toggleVisibility(index, false);
                            } else {
                                if (this.getGroupNumber(this.textareas[index])==0 ){
                                    this.highlightGroup(index);
                                    this.toggleVisibility(index, false);
                                } else {
                                    this.highlightGroupOff(index);
                                    this.highlightGroup(index);
                                    this.toggleVisibility(index, false);
                                }
                            }
                        }
                        break;
                    case '開く':
                        
                        this.toggleVisibility(index, true);
                        break;
                    case 'G':
                        this.toggleHighlightGroup(index);
                        break;
                    case '↑':
                        //カーソルがあるのがハイライトされたテキストエリアの場合---
                        if (textarea.style.backgroundColor !== '') {
                            //そのブロックの一番上のインデックスを取得
                            let now_gpnum=this.getGroupNumber(this.textareas[index]);
                            const highlightedIndexes = this.getHighlightedIndexes();
                            while (highlightedIndexes.includes(cindex) && this.getGroupNumber(this.textareas[cindex])===now_gpnum) {
                                //カレントインデックスを減らしていく
                                cindex--;
                            }
                            // 一番上のindex
                            let firstHighlightedIndex=cindex+1;
                            //alert('自分のブロックの先頭'+firstHighlightedIndex);

                            //真上取得
                            const aboveContainer = this.textareas[firstHighlightedIndex - 1];
                            const aboveTextarea = aboveContainer.querySelector('textarea');
                            //alert('真上' +(firstHighlightedIndex - 1));

                            //真上がハイライトされている場合
                            if (aboveTextarea.style.backgroundColor !== '') {
                                //真上のハイライトされているテキストエリアの数を数える
                                let tcount=this.countGroupMembers(firstHighlightedIndex - 1);
                                //alert('真上のブロックの本数'+tcount);
                                //indexを減じながら、その数だけupを繰り返し、真上のブロックを超える
                                for(let i=0;i<tcount;i++){
                                    //alert((firstHighlightedIndex+i)+'を上げる');
                                    this.moveHighlightedUp(firstHighlightedIndex-i);
                                }
                            } else {
                                //真上がハイライトされていない場合
                                this.moveHighlightedUp(index);
                            }
                            //カーソルがあるのはハイライトされていないテキストエリアの場合    
                        } else {
                            //それがてっぺんのテキストエリアなら何もしない
                            if (index > 0) { 
                                // ２行使って、真上のテキストエリア取得
                                const aboveContainer = this.textareas[index - 1];
                                const aboveTextarea = aboveContainer.querySelector('textarea');
                                // 真上のテキストエリアがハイライトされている場合
                                if (aboveTextarea.style.backgroundColor !== '') {
                                    this.moveHighlightedDown((index-1)); 
                                    let textarea = event.target;
                                    let container = textarea.closest('.textarea-container');
                                    let cindex = this.textareas.indexOf(container);
                                    this.moveCursor(cindex,0); 
                                } else {
                                    //カーソル位置は現在のテキストエリア内のカーソル位置になる。
                                    const cursorPosition = textarea.selectionStart;
                                    //indexのテキストエリアが真上と入れ替わる
                                    this.swapWithAbove(index, cursorPosition);
                                }

                            }
                        }
                        /*
                        this.handleKeyDown({
                            target: textarea,
                            ctrlKey: true,
                            key: 'ArrowUp',
                            preventDefault: () => {} // ダミーの preventDefault メソッド                            
                        });
                        */
                        break;
                    case '↓':
                       //カーソルがあるのがハイライトされたテキストエリアの場合
                        if (textarea.style.backgroundColor !== '') {
                            //自身のハイライトされているテキストエリアの数を数える ２個
                            let tcount=this.countGroupMembers(index);
                            //alert('このブロックの本数'+tcount);
                            //自分のグループの真下取得　自分１＋２
                            const belowContainer = this.textareas[index + tcount];
                            const belowTextarea = belowContainer.querySelector('textarea');
                            //alert('真下' +(index + tcount));
                            //自分のグループの真下がハイライトされている場合
                            if (belowTextarea.style.backgroundColor !== '') {
                                //自分のブロックの一番上のインデックスを取得
                                let now_gpnum=this.getGroupNumber(this.textareas[index]);
                                const highlightedIndexes = this.getHighlightedIndexes();
                                while (highlightedIndexes.includes(cindex) && this.getGroupNumber(this.textareas[cindex])===now_gpnum) {
                                    //カレントインデックスを減らしていく
                                    cindex--;
                                }
                                // 一番上のindex
                                let firstHighlightedIndex=cindex+1;
                                //alert('自分のブロックの先頭'+firstHighlightedIndex);

                                //真下のハイライトされているテキストエリアの数を数える
                                let tcount2=this.countGroupMembers(index + tcount);
                                //alert('真下のブロックの本数'+tcount2);
                                //indexを増やしながら、真下のブロックを超える
                                for(let i=0;i<tcount2;i++){
                                    //alert((firstHighlightedIndex+i)+'を下げる');
                                    this.moveHighlightedDown(firstHighlightedIndex+i);
                                }
                            } else {
                                //真下がハイライトされていない場合
                                this.moveHighlightedDown(index);
                            }
                        //カーソルがあるのはハイライトされていないテキストエリアの場合    
                        } else {
                            //それが一番下のテキストエリアなら何もしない
                            if (index < this.textareas.length - 1) { 
                                // ２行使って、真下のテキストエリア取得
                                const belowContainer = this.textareas[index + 1];
                                const belowTextarea = belowContainer.querySelector('textarea');
                                //真下がハイライトされている場合
                                if (belowTextarea.style.backgroundColor !== '') {
                                    // カーソルをそのテキストエリアに移して、
                                    //そのテキストエリアを上にあげる
                                    //this.moveCursor(index+1,0);  
                                    this.moveHighlightedUp((index+1));
                                    
                                    const textarea = event.target;
                                    const container = textarea.closest('.textarea-container');
                                    let cindex = this.textareas.indexOf(container);
                                    this.moveCursor(cindex,0); 
                                } else {
                                    //カーソル位置は現在のテキストエリア内のカーソル位置になる。
                                    const cursorPosition = textarea.selectionStart;
                                    //indexのテキストエリアが真下と入れ替わる
                                    this.swapWithBelow(index, cursorPosition);
                                }
                            }
                        }
                        /*
                        this.handleKeyDown({
                            target: textarea,
                            ctrlKey: true,
                            key: 'ArrowDown',
                            preventDefault: () => {} // ダミーの preventDefault メソッド                            
                        });
                        */
                        break;
                }
            }

            toggleHighlightGroup(index) {
                const highlightedIndexes = this.getHighlightedIndexes();
                if(highlightedIndexes.includes(index) ){
                    //this.clearHighlight();
                    //alert(1);
                    this.highlightGroupOff(index);
                } else {
                    //0707 this.clearHighlight();
                    this.highlightGroup(index);
                }
            }

            clearHighlight() {
                this.textareas.forEach(container => {
                    container.querySelector('textarea').style.backgroundColor = '';
                });
            }

            highlightGroupOff(index) {

                //そのindexのグループ番号を取得して
                //同じグループを解除する
                let g_num1=this.getGroupNumber(this.textareas[index]);
                //alert(g_num1);
                let g_num2;
                for(let i=0;i<this.textareas.length;i++){
                    g_num2=this.getGroupNumber(this.textareas[i]);
                    if(g_num2===g_num1){
                        this.textareas[i].querySelector('textarea').style.backgroundColor = '';
                        this.setGroupNumber(this.textareas[i], 0);
                    }
                }

                /*
                const startIndent = this.getIndent(this.textareas[index]);
                
                for (let i = index; i < this.textareas.length; i++) {
                    const currentIndent = this.getIndent(this.textareas[i]);
                    if (i === index || currentIndent > startIndent) {
                        this.textareas[i].querySelector('textarea').style.backgroundColor = '';
                        //yas
                        this.setGroupNumber(this.textareas[i], 0);
                    } else {
                        break;
                    }
                }
                */    
            }


            highlightGroup(index) {
                const startIndent = this.getIndent(this.textareas[index]);
                let newGroupNumber;
                
                //真下にテキストエリアがある場合
                if(index<(this.textareas.length-1)){
                    //真下のテキストエリアのインデントを取得
                    const nextIndent = this.getIndent(this.textareas[index+1]);
                    const nowIndent = this.getIndent(this.textareas[index]);
                    //真下のテキストエリアのインデントが自分より右にある場合はグループ化
                    if(nextIndent > nowIndent){
                        //このテキストエリアを取得
                        const nowContainer = this.textareas[index];
                        const nowTextarea = nowContainer.querySelector('textarea');
                        //このテキストエリアがすでにグループ番号を持っているなら
                        if (nowTextarea.style.backgroundColor !== '') {
                            //そのグループ番号を使う
                            newGroupNumber=this.getGroupNumber(this.textareas[index]);
                        } else {    
                            this.maxGroupNumber++;
                            newGroupNumber = this.maxGroupNumber;
                        }
                        this.updateMaxGroupNumberDisplay();

                        // 新しい背景色を取得
                        const backgroundColor = this.getBackgroundColor(newGroupNumber);

                        for (let i = index; i < this.textareas.length; i++) {
                            const currentIndent = this.getIndent(this.textareas[i]);
                            if (i === index || currentIndent > startIndent) {
                                this.textareas[i].querySelector('textarea').style.backgroundColor = backgroundColor;
                                this.setGroupNumber(this.textareas[i], newGroupNumber);                         
                            } else {
                                break;
                            }
                        }
                    }
                }

                //そのindexがブロック化済で
                //真上と違うグループ番号なら、そのグループ番号を使う。

            }

            // 新しい関数: グループ番号に基づいて背景色を返す
            getBackgroundColor(groupNumber) {
                // パステルカラーの配列
                const colors = [
                    '#FFD3E0', '#FFF0D3', '#D3FFD3', '#D3F0FF', '#E0D3FF',
                    '#FFE0D3', '#D3FFE0', '#D3E0FF', '#FFD3F0', '#F0FFD3'
                ];
                
                // グループ番号に基づいて色を選択（循環させる）
                return colors[(groupNumber % 10) % colors.length];
            }

            //yas
            getGroupNumber(container) {
                const textarea = container.querySelector('textarea');
                return parseInt(textarea.dataset.groupNumber || '0');
            }
            //yas
            setGroupNumber(container, number) {
                const textarea = container.querySelector('textarea');
                textarea.dataset.groupNumber = number.toString();
                const groupNumberDisplay = container.querySelector('.group-number-display');
                if (groupNumberDisplay) {
                    groupNumberDisplay.textContent = `グループ: ${number}`;
                }
            }
            //yas
            updateMaxGroupNumberDisplay() {
                this.groupNumberDisplay.textContent = `最大グループ番号: ${this.maxGroupNumber}`;
                this.groupNumberDisplay.style.visibility = 'hidden';
            }


            moveTextareas(index, direction, cursorPosition = null) {
                const newIndex = index + direction;

                if (newIndex < 0 || newIndex >= this.textareas.length) {
                    return false;
                }

                const temp = this.textareas[index];
                this.textareas[index] = this.textareas[newIndex];
                this.textareas[newIndex] = temp;

                this.updateDOM();

                const movedTextarea = this.textareas[newIndex].querySelector('textarea');
                movedTextarea.focus();
                if (cursorPosition !== null) {
                    movedTextarea.selectionStart = movedTextarea.selectionEnd = Math.min(cursorPosition, movedTextarea.value.length);
                }

                return true;
            }

            shiftIndent(startIndex, direction) {
                const startIndent = this.getIndent(this.textareas[startIndex]);
                let i = startIndex;

                while (i < this.textareas.length) {
                    const currentIndent = this.getIndent(this.textareas[i]);
                    if (i > startIndex && currentIndent <= startIndent) break;

                    const newIndent = Math.max(0, currentIndent + direction);
                    this.setIndent(this.textareas[i], newIndent);
                    i++;
                }

                this.updateDOM();
            }

            //showがtrueだと２つ目以降が表示、falseだと非表示になる
            toggleVisibility(startIndex, show) {
                // デバッグ用：開始インデックスをログ出力
                console.log(startIndex);

                // 開始要素のインデントレベルを取得
                const startIndent = this.getIndent(this.textareas[startIndex]);
                // 閉じるボタンのスタイルを更新

                //２つ目以降を処理
                let i = startIndex + 1;

                // 開始要素より深いインデントの要素を処理
                while (i < this.textareas.length) {
                    const currentIndent = this.getIndent(this.textareas[i]);
                    // 開始要素以下のインデントレベルになったら処理を終了
                    if (currentIndent <= startIndent) break;
                    
                    if(i===(startIndex + 1)){
                        let closeButton = this.textareas[startIndex].querySelector('.close-button');
                        let openButton = this.textareas[startIndex].querySelector('.open-button');
                        if (show===true) {
                            closeButton.style.display = '';
                            openButton.style.display = 'none';
                        } else {
                            closeButton.style.display = 'none';
                            openButton.style.display = '';
                        }
                    }
                    let closeButton = this.textareas[i].querySelector('.close-button');
                    let openButton = this.textareas[i].querySelector('.open-button');

                    // ２つ目以降を１つずつ表示（非表示）に  ※３つ目以降も非表示なら表示にってやってるからだめなんだ。非表示なのか、表示なのかは２つ目で決める！
                    if(show===true){
                        this.textareas[i].style.display='';
                        closeButton.style.display = '';
                        openButton.style.display = 'none';
                    } else {
                        this.textareas[i].style.display='none';
                        closeButton.style.display = 'none';
                        openButton.style.display = '';
                    }
                    i++;
                }

                // デバッグ用：処理後の開始インデックスをログ出力
                console.log(startIndex);

                // 表示に切り替える場合、遅延してフォーカスを設定
                setTimeout(() => {
                    const nowTextarea = this.textareas[startIndex].querySelector('textarea');
                    nowTextarea.focus();
                    this.moveCursor(startIndex, 0);
                    // カーソルを先頭に移動
                    nowTextarea.selectionStart = nowTextarea.selectionEnd = 0;
                }, 100); // 100msの遅延を追加


                // DOM更新処理を呼び出し
                this.updateDOM();
            }

            updateCloseButtons() {
                this.textareas.forEach((container, index) => {
                    const closeButton = container.querySelector('.close-button');
                    const startIndent = this.getIndent(container);
                    let i = index + 1;
                    let hasHiddenTextareas = false;

                    while (i < this.textareas.length) {
                        const currentIndent = this.getIndent(this.textareas[i]);
                        if (currentIndent <= startIndent) break;

                        if (this.textareas[i].style.display === 'none') {
                            hasHiddenTextareas = true;
                            break;
                        }
                        i++;
                    }

                });
            }

            //ブロックの中の任意のインデックスをもらって、ブロックの本数を返す
            countGroupMembers(cindex){
                
                // グループ番号の取得
                let now_gpnum=this.getGroupNumber(this.textareas[cindex]);
                // ハイライトされたテキストエリアのインデックスを取得する
                const highlightedIndexes = this.getHighlightedIndexes();
                
                //このブロックの先頭の把握
                let i=cindex;
                while (highlightedIndexes.includes(i) && this.getGroupNumber(this.textareas[i])===now_gpnum) {
                    //カレントインデックスを減らしていく
                    i--;
                }
                // 一番上のindex
                let first=i+1;
                //alert('first'+first);

                //このハイライトグループの最後尾の把握---------------------------------
                i=cindex;
                while (highlightedIndexes.includes(i) && this.getGroupNumber(this.textareas[i])===now_gpnum) {
                    //カレントインデックスを増やしていく
                    i++;
                }
                let last=i-1;
                // 本数の算出
                //alert('last'+last);
                //alert('本数'+(last-first+1));
                return (last-first+1);
            }


            //ハイライトされたグループの真上のハイライトされていないテキストエリアを
            //ハイライトされたグループの個数分下に下げる。            
            moveHighlightedUp(cindex,direction) {
                //このハイライトされたテキストエリアのグループ番号を取得する
                let now_gpnum=this.getGroupNumber(this.textareas[cindex]);
                // ハイライトされたテキストエリアのインデックスを取得する
                const highlightedIndexes = this.getHighlightedIndexes();

                //このハイライトグループの最後尾の把握---------------------------------
                    while (highlightedIndexes.includes(cindex) && this.getGroupNumber(this.textareas[cindex])===now_gpnum) {
                        //カレントインデックスを増やしていく
                        cindex++;
                    }
                    // 最終的なcindexの値を確認
                    let lastHighlightedIndex=cindex-1;

                //このハイライトグループの先頭の把握---------------------------------
                    cindex=lastHighlightedIndex
                    while (highlightedIndexes.includes(cindex) && this.getGroupNumber(this.textareas[cindex])===now_gpnum) {
                        //カレントインデックスを増やしていく
                        cindex--;
                    }
                    // 最終的なcindexの値を確認
                    let firstHighlightedIndex=cindex+1;

                // ハイライトされたテキストエリアの中で一番上のテキストエリアが１行目ではないことを確認する
                if (firstHighlightedIndex != 0) {
                    //ハイライトされた小集団の真上のハイライトされていないテキストエリアのインデックスを取得
                    let currentIndex = firstHighlightedIndex-1 ;
                    // ハイライトされていないカレントインデックスのテキストエリアを下に移動
                    for (let i = currentIndex; i < lastHighlightedIndex ; i++) {
                        // ハイライトされていないテキストエリアを上に(カーソル位置はテキストの先頭に)
                        this.swapWithBelow(i, 0); 
                    }
                    this.moveCursor(firstHighlightedIndex-1,0)
                }
            }

            //ハイライトされたグループの真下のハイライトされていないテキストエリアを
            //ハイライトされたグループの個数分上に上げる            
            moveHighlightedDown(cindex) {
                //このハイライトされたテキストエリアのグループ番号を取得する
                let now_gpnum=this.getGroupNumber(this.textareas[cindex]);
                // ハイライトされたテキストエリアのインデックスを取得する
                const highlightedIndexes = this.getHighlightedIndexes();

                //このハイライトグループの最後尾の把握---------------------------------
                while (highlightedIndexes.includes(cindex) && this.getGroupNumber(this.textareas[cindex])===now_gpnum) {
                    //カレントインデックスを増やしていく
                    cindex++;
                }
                // 最後尾
                let lastHighlightedIndex=cindex-1;

                //このハイライトグループの先頭の把握---------------------------------
                cindex=lastHighlightedIndex
                while (highlightedIndexes.includes(cindex) && this.getGroupNumber(this.textareas[cindex])===now_gpnum) {
                    //カレントインデックスを増やしていく
                    cindex--;
                }
                // 先頭
                let firstHighlightedIndex=cindex+1;

                // ハイライトされたテキストエリアの中で一番下のテキストエリアが最終行ではないことを確認する
                if (lastHighlightedIndex < this.textareas.length - 1) {
                    //ハイライトされた小集団の真下のハイライトされていないテキストエリアのインデックスを取得
                    let currentIndex = lastHighlightedIndex + 1;
                    // ハイライトされていないカレントインデックスのテキストエリアを上に移動
                    for (let i = currentIndex; i > firstHighlightedIndex ; i--) {
                        // ハイライトされていないテキストエリアを上に(カーソル位置はテキストの先頭に)
                        this.swapWithAbove(i, 0); 
                    }
                    this.moveCursor(firstHighlightedIndex+1,0)
                }
            }
            
            //indexのテキストエリアをindex-1（１つ上）のテキストエリアと入れ替える
            //テキストの先頭にカーソルを置きたい場合はcursorPositionは0にする
            //テキストエリアのどこにカーソルを置くか指定したないときはnullにする
            swapWithAbove(index, cursorPosition) {
                // 上に交換するテキストエリアがあることを確認する
                if (index > 0) {
                    console.log('下:', index);
                    console.log('上:', index-1);
                    const temp = this.textareas[index];

                    this.textareas[index] = this.textareas[index - 1];
                    this.textareas[index - 1] = temp; // 現在のテキストエリアを上のテキストエリアと交換する

                    this.updateDOM(); // DOM を更新して新しい順序を反映させる

                    const aboveTextarea = this.textareas[index - 1].querySelector('textarea');
                    aboveTextarea.focus(); // 移動したテキストエリアにフォーカスを設定する
                    if (cursorPosition !== null) {
                        //cursorPositionにカーソルを置く
                        aboveTextarea.selectionStart = aboveTextarea.selectionEnd = cursorPosition; 
                    }
                }
            }

            //indexのテキストエリアをindex+1（１つ下）のテキストエリアと入れ替える
            //テキストの先頭にカーソルを置きたい場合はcursorPositionは0にする
            //テキストエリアのどこにカーソルを置くか指定したないときはnullにする
            swapWithBelow(index, cursorPosition) {
                if (index < this.textareas.length - 1) { // 最後のテキストエリアではないことを確認する
                    const temp = this.textareas[index];
                    this.textareas[index] = this.textareas[index + 1];
                    this.textareas[index + 1] = temp;// 現在のテキストエリアを下のテキストエリアと交換する

                    this.updateDOM();

                    const belowTextarea = this.textareas[index + 1].querySelector('textarea');
                    belowTextarea.focus(); // 移動したテキストエリアにフォーカスを設定する
                    if (cursorPosition !== null) {
                        belowTextarea.selectionStart = belowTextarea.selectionEnd = cursorPosition;
                        // カーソル位置を保持する（指定されている場合）
                    }
                }
            }


            getHighlightedIndexes() {
                return this.textareas.map((container, index) => {
                    const textarea = container.querySelector('textarea');
                    if (textarea.style.backgroundColor !== '') {
                        return index;
                    }
                    return null;
                }).filter(index => index !== null);
            }
        
            importCSV() {
 
                let text_count=this.textareas.length
                const file = document.getElementById('csvFile').files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const content = e.target.result;
                        const lines = content.split('\n');
                        lines.forEach(line => {
                            if (line.trim() !== '') {
                                const [text, indent] = line.split(',');
                                this.addTextarea2(parseInt(indent),text);
                            }
                        });
                        this.updateGrouping();
                        this.updateDOM();
                    };
                    reader.readAsText(file);
                    setTimeout(() => {
                            for(let i=1;i<=text_count;i++){
                                this.removeTextarea(0);
                                this.updateDOM();
                            }
                        }, 100);                    

                }


            }        
        }

        new TextareaManager();
    </script>

<textarea id="moto"></textarea><br> 
<pre id="yasu">
</pre>

<!--ローカルの場合は以下の一文を入れる
<script src="./mermaid.min.js"></script>-->

<script type="module">
    //ローカルの場合は以下の一文を削除
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';

    //ローカルの場合は以下の一文を入れる
    //mermaid.initialize({ startOnLoad: true});
    //ローカルの場合は以下の一文をコメントアウト
    mermaid.initialize({ startOnLoad: false,securityLevel: 'loose' });
    window.myfunction=function make_tree(){
        document.getElementById("yasu").removeAttribute('data-processed');
        document.getElementById("yasu").innerHTML="";
        document.getElementById("yasu").innerHTML=document.getElementById("moto").value;
        mermaid.run({nodes:[document.getElementById("yasu")]});
    }
</script>

<div id="dst">
</div>

<button id="neko1" onclick="captureHighResImage()" class="upcontrols" style="display: none;">表示されているツリー図やマインドマップを画像としてコピー（safariでは使用不可）</button><br>
<button id="neko2" onclick="hideImage()" class="upcontrols" style="display: none;">表示されているツリー図やマインドマップを消す</button>

<!--ローカルの場合は以下の一文を入れる
<script src="./html2canvas.min.js"></script>-->
<!--ローカルの場合は以下の一文をコメントアウト-->
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
<script>
function hideImage() {
    document.getElementById("yasu").innerHTML='';
    document.getElementById('neko1').style.display='none';
    document.getElementById('neko2').style.display='none';

}    
async function captureHighResImage() {
    const src = document.getElementById('yasu');
    const svg = src.querySelector('svg');
    
    if (!svg) {
        console.error('SVG element not found');
        return;
    }
    
    const bbox = svg.getBBox();
    const svgRect = svg.getBoundingClientRect();
    
    // スケール係数を計算
    const scaleX = svgRect.width / bbox.width;
    const scaleY = svgRect.height / bbox.height;
    
    // 基本的なスケールファクター（デバイスのピクセル比）
    const baseScale = window.devicePixelRatio || 1;
    
    // 追加の解像度倍率（必要に応じて調整）
    const resolutionMultiplier = 2;
    
    // 最終的なスケールファクター
    const finalScale = baseScale * resolutionMultiplier;
    
    // キャプチャ範囲を計算（下部に余白を追加）
    const captureWidth = Math.ceil(bbox.width * scaleX);
    const captureHeight = Math.ceil(bbox.height * scaleY + 20); // 20pxの余白
    
    const canvas = await html2canvas(src, {
        width: captureWidth,
        height: captureHeight,
        x: bbox.x * scaleX,
        y: bbox.y * scaleY,
        scale: finalScale,
        logging: false,
        useCORS: true, // クロスオリジンの画像をサポート
        allowTaint: false, // セキュリティのため、デフォルトはfalse
        backgroundColor: null // 透明背景
    });

    // 以下、キャンバスの処理（クリップボードへのコピーなど）
    canvas.toBlob(function(blob) {
        const item = new ClipboardItem({ "image/png": blob });
        navigator.clipboard.write([item]).then(() => {
            console.log('Image copied to clipboard');
        }).catch(err => {
            console.error('Failed to copy image: ', err);
        });
    });
    // ここでcanvasを削除します
    canvas.remove();
}   

</script>


</body>
</html>
